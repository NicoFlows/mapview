<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Map Viewer</title>
  <style>
    :root { color-scheme: light; }
    body { margin:0; font-family: "Times New Roman", Georgia, serif; background:#9a9a8a; color:#3a3a2a; }
    header { display:flex; gap:12px; align-items:center; padding:10px 12px; border-bottom:1px solid #7a7a6a; position:sticky; top:0; background:#e8e4d8; z-index:2; flex-wrap: wrap; }
    .btn { background:#d8d4c8; border:1px solid #8a8a7a; color:#3a3a2a; padding:8px 10px; border-radius:6px; cursor:pointer; font-family: inherit; }
    .btn:hover { background:#c8c4b8; }
    .btn.active { background:#7a9a6a; color:white; border-color:#5a7a4a; }
    .chip { padding:6px 10px; border:1px solid #8a8a7a; border-radius:999px; background:#e8e4d8; font-size:12px; opacity:.9; color:#3a3a2a; }
    .chip.clickable { cursor:pointer; transition: all 0.15s; }
    .chip.clickable:hover { background:#d8d4c8; border-color:#6a6a5a; transform: translateY(-1px); }
    #wrap { position:relative; height: calc(100vh - 54px); }
    canvas { display:block; width:100%; height:100%; }
    #tip {
      position:absolute; pointer-events:none; padding:10px 12px; max-width:360px;
      background:rgba(245,242,235,.96); border:1px solid #8a8a7a; border-radius:8px;
      box-shadow: 0 4px 16px rgba(0,0,0,.2); display:none; font-size:13px; line-height:1.35;
      color: #3a3a2a; font-family: "Times New Roman", Georgia, serif;
    }
    #tip .t { font-weight:700; margin-bottom:6px; color: #2a2a1a; }
    #tip .k { opacity:.65; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; }
    #legend { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }

    /* Building info panel */
    #buildingPanel {
      position: absolute;
      top: 60px;
      right: 10px;
      width: 320px;
      max-height: calc(100vh - 120px);
      overflow-y: auto;
      background: rgba(245,242,235,.98);
      border: 1px solid #8a8a7a;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,.25);
      padding: 16px;
      display: none;
      z-index: 10;
    }
    #buildingPanel.visible { display: block; }
    #buildingPanel h3 { margin: 0 0 12px 0; font-size: 16px; color: #2a2a1a; }
    #buildingPanel .info-row { margin-bottom: 8px; font-size: 13px; }
    #buildingPanel .info-row label { display: block; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; opacity: 0.7; margin-bottom: 2px; }
    #buildingPanel input[type="text"], #buildingPanel textarea {
      width: 100%; padding: 8px; border: 1px solid #a0a090; border-radius: 4px;
      font-family: inherit; font-size: 13px; box-sizing: border-box;
    }
    #buildingPanel textarea { min-height: 60px; resize: vertical; }
    #buildingPanel .btn-row { display: flex; gap: 8px; margin-top: 12px; }
    #buildingPanel .btn-sm {
      padding: 6px 12px; font-size: 12px; flex: 1;
      background: #d8d4c8; border: 1px solid #8a8a7a; border-radius: 4px; cursor: pointer;
    }
    #buildingPanel .btn-sm:hover { background: #c8c4b8; }
    #buildingPanel .btn-sm.primary { background: #7a9a6a; color: white; border-color: #5a7a4a; }
    #buildingPanel .btn-sm.primary:hover { background: #6a8a5a; }
    #buildingPanel .floor-tabs { display: flex; gap: 4px; margin: 12px 0 8px 0; flex-wrap: wrap; }
    #buildingPanel .floor-tab {
      padding: 4px 10px; font-size: 11px; background: #e8e4d8; border: 1px solid #a0a090;
      border-radius: 4px; cursor: pointer;
    }
    #buildingPanel .floor-tab.active { background: #7a9a6a; color: white; border-color: #5a7a4a; }
    #buildingPanel .floor-preview {
      background: #f8f6f0; border: 1px solid #c0c0b0; border-radius: 4px;
      min-height: 150px; position: relative;
    }
    #buildingPanel .close-btn {
      position: absolute; top: 8px; right: 8px; width: 24px; height: 24px;
      background: none; border: none; font-size: 18px; cursor: pointer; opacity: 0.6;
    }
    #buildingPanel .close-btn:hover { opacity: 1; }

    /* Game square info panel */
    #squarePanel {
      position: absolute;
      top: 60px;
      left: 10px;
      width: 280px;
      max-height: calc(100vh - 120px);
      overflow-y: auto;
      background: rgba(245,242,235,.98);
      border: 1px solid #8a8a7a;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,.25);
      padding: 16px;
      display: none;
      z-index: 10;
    }
    #squarePanel.visible { display: block; }
    #squarePanel h3 { margin: 0 0 12px 0; font-size: 16px; color: #2a2a1a; }
    #squarePanel .info-row { margin-bottom: 8px; font-size: 13px; }
    #squarePanel .info-row label { display: block; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; opacity: 0.7; margin-bottom: 2px; }
    #squarePanel input[type="text"], #squarePanel textarea {
      width: 100%; padding: 8px; border: 1px solid #a0a090; border-radius: 4px;
      font-family: inherit; font-size: 13px; box-sizing: border-box;
    }
    #squarePanel textarea { min-height: 60px; resize: vertical; }
    #squarePanel .btn-row { display: flex; gap: 8px; margin-top: 12px; }
    #squarePanel .btn-sm {
      padding: 6px 12px; font-size: 12px; flex: 1;
      background: #d8d4c8; border: 1px solid #8a8a7a; border-radius: 4px; cursor: pointer;
    }
    #squarePanel .btn-sm:hover { background: #c8c4b8; }
    #squarePanel .btn-sm.primary { background: #7a9a6a; color: white; border-color: #5a7a4a; }
    #squarePanel .btn-sm.primary:hover { background: #6a8a5a; }
    #squarePanel .close-btn {
      position: absolute; top: 8px; right: 8px; width: 24px; height: 24px;
      background: none; border: none; font-size: 18px; cursor: pointer; opacity: 0.6;
    }
    #squarePanel .close-btn:hover { opacity: 1; }
    #squarePanel .district-color {
      display: inline-block; width: 12px; height: 12px; border-radius: 3px;
      vertical-align: -1px; margin-right: 6px; border: 1px solid rgba(0,0,0,0.2);
    }

    /* Edit tools palette */
    #editToolsPanel {
      position: absolute;
      top: 60px;
      right: 10px;
      width: 220px;
      background: rgba(245,242,235,.98);
      border: 1px solid #8a8a7a;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,.25);
      padding: 12px;
      display: none;
      z-index: 11;
    }
    #editToolsPanel.visible { display: block; }
    #editToolsPanel h3 {
      margin: 0 0 10px 0;
      font-size: 15px;
      color: #2a2a1a;
    }
    #editToolsPanel .row { margin-bottom: 8px; }
    #editToolsPanel .btn-sm {
      width: 100%;
      padding: 7px 10px;
      font-size: 12px;
      background: #d8d4c8;
      border: 1px solid #8a8a7a;
      border-radius: 4px;
      cursor: pointer;
      font-family: inherit;
      color: #3a3a2a;
    }
    #editToolsPanel .btn-sm:hover { background: #c8c4b8; }
    #editToolsPanel .btn-sm.active {
      background: #7a9a6a;
      border-color: #5a7a4a;
      color: #fff;
    }
    #editToolsPanel .hint {
      margin: 8px 0 0 0;
      font-size: 11px;
      line-height: 1.35;
      color: #5a5a4a;
    }
  </style>
</head>
<body>
  <header>
    <input id="file" type="file" accept=".json,application/json" class="btn" />
    <button id="fit" class="btn">Fit</button>
    <button id="editMapBtn" class="btn" style="display:none">Edit Map</button>
    <button id="generateSquaresBtn" class="btn" style="display:none">Generate Squares</button>
    <button id="toggleSquaresBtn" class="btn" style="display:none">Toggle Squares</button>
    <label class="btn" id="boardStateLabel" style="display:none; cursor:pointer">
      Load Board State
      <input id="boardStateFile" type="file" accept=".json,application/json" style="display:none" />
    </label>
    <button id="export" class="btn" style="display:none">Export</button>
    <span id="meta" class="chip">No file loaded</span>
    <div id="legend"></div>
    <input type="color" id="colorPicker" style="position:absolute;opacity:0;pointer-events:none" />
  </header>

  <div id="wrap">
    <canvas id="c"></canvas>
    <div id="tip"></div>

    <!-- Building info panel -->
    <div id="buildingPanel">
      <button class="close-btn" id="closeBuildingPanel">&times;</button>
      <h3 id="buildingTitle">Building #0</h3>
      <div class="info-row">
        <label>Area</label>
        <span id="buildingArea">0 sq units</span>
      </div>
      <div class="info-row">
        <label>Name</label>
        <input type="text" id="buildingName" placeholder="Give this building a name..." />
      </div>
      <div class="info-row">
        <label>Notes</label>
        <textarea id="buildingNotes" placeholder="Add notes about this building..."></textarea>
      </div>
      <div class="btn-row">
        <button class="btn-sm" id="generateDwelling">Generate Dwelling</button>
        <button class="btn-sm primary" id="saveBuildingInfo">Save</button>
      </div>
      <div id="dwellingSection" style="display:none; margin-top: 16px; border-top: 1px solid #c0c0b0; padding-top: 12px;">
        <label style="font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; opacity: 0.7;">Dwelling Preview</label>
        <div class="floor-tabs" id="floorTabs"></div>
        <div class="floor-preview">
          <canvas id="floorCanvas" width="288" height="150"></canvas>
        </div>
      </div>
    </div>

    <!-- Game square info panel -->
    <div id="squarePanel">
      <button class="close-btn" id="closeSquarePanel">&times;</button>
      <h3 id="squareTitle">Block A</h3>
      <div class="info-row">
        <label>Square ID</label>
        <span id="squareId" style="font-family:monospace;font-size:12px">-</span>
      </div>
      <div class="info-row">
        <label>District</label>
        <span id="squareDistrict">-</span>
      </div>
      <div class="info-row">
        <label>Buildings</label>
        <span id="squareBuildingCount">0</span>
      </div>
      <div class="info-row">
        <label>Area</label>
        <span id="squareAreaInfo">0 sq units</span>
      </div>
      <!-- Board state data (hidden until board state loaded) -->
      <div id="boardStateSection" style="display:none; border-top: 1px solid #c0c0b0; margin-top: 10px; padding-top: 10px;">
        <div class="info-row">
          <label>VP</label>
          <span id="squareVP" style="font-weight:bold">-</span>
        </div>
        <div class="info-row">
          <label>Influence</label>
          <span id="squareInfluence">-</span>
        </div>
        <div class="info-row">
          <label>Controller</label>
          <span id="squareController">-</span>
        </div>
        <div class="info-row">
          <label>Adjacent</label>
          <span id="squareAdjacent" style="font-size:12px">-</span>
        </div>
        <div style="border-top: 1px solid #d0d0c0; margin-top: 8px; padding-top: 8px;">
          <div class="info-row">
            <label>District VP</label>
            <span id="squareDistrictVP">-</span>
          </div>
          <div class="info-row">
            <label>Faction</label>
            <span id="squareFaction">-</span>
          </div>
          <div class="info-row">
            <label>Special Ability</label>
            <span id="squareAbility" style="font-size:12px">-</span>
          </div>
        </div>
      </div>
      <div class="info-row" style="margin-top:10px">
        <label>Name</label>
        <input type="text" id="squareName" placeholder="Name this square..." />
      </div>
      <div class="info-row">
        <label>Notes</label>
        <textarea id="squareNotes" placeholder="Add notes about this square..."></textarea>
      </div>
      <div class="btn-row">
        <button class="btn-sm primary" id="saveSquareInfo">Save</button>
      </div>
    </div>

    <!-- Edit tools panel -->
    <div id="editToolsPanel">
      <h3>Map Editing</h3>
      <div class="row">
        <button id="editMoveBuildingsBtn" class="btn-sm">Move Buildings</button>
      </div>
      <div class="row">
        <button id="editRotateBuildingsBtn" class="btn-sm">Rotate Buildings</button>
      </div>
      <div class="row">
        <button id="editAddRoadBtn" class="btn-sm">Add Road</button>
      </div>
      <div class="row">
        <button id="editToggleGridBtn" class="btn-sm">Grid</button>
      </div>
      <div class="row">
        <button id="editToggleLabelsBtn" class="btn-sm">Labels</button>
      </div>
      <div class="row">
        <button id="duplicateBuildingBtn" class="btn-sm">Duplicate Building</button>
      </div>
      <p class="hint">Tip: select a building first, then duplicate/move/rotate. Click the active tool again to exit it.</p>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  const tip = document.getElementById("tip");
  const meta = document.getElementById("meta");
  const legend = document.getElementById("legend");

  let showGrid = true;
  let showLabels = true;

  // Camera
  let panX = 0, panY = 0, zoom = 1;
  let isPanning = false, lastX = 0, lastY = 0;
  let suppressNextClick = false;

  // Data
  let map = null;
  let mapType = null; // 'hex' or 'city'
  let hexSize = 22;
  let bounds = null;
  let hitIndex = [];

  // City map parsed data
  let cityData = null;
  let currentFileName = "map.json";

  // Custom colors (overrides defaults, saved with map)
  let customColors = {};

  // Game squares state
  let gameSquares = [];
  let showGameSquares = false;
  let selectedSquareIndex = null;

  // Board state integration
  let loadedBoardState = null;
  const PLAYER_COLORS = {
    1: '#4488cc',  // Blue
    2: '#cc4444',  // Red
    3: '#44aa44',  // Green
    4: '#cc8844',  // Orange
  };

  function parseController(controller) {
    const uncontrolled = { controlled: false, playerNum: 0, label: "Uncontrolled" };

    if (controller === null || controller === undefined) return uncontrolled;

    if (typeof controller === "number") {
      const n = Number.isFinite(controller) ? Math.max(0, Math.floor(controller)) : 0;
      if (n <= 0) return uncontrolled;
      return { controlled: true, playerNum: n, label: `Player ${n}` };
    }

    if (typeof controller === "string") {
      const s = controller.trim();
      if (!s || /^(none|uncontrolled|null|0)$/i.test(s)) return uncontrolled;
      const m = s.match(/\d+/);
      const n = m ? (parseInt(m[0], 10) || 0) : 0;
      return { controlled: true, playerNum: n, label: s };
    }

    if (typeof controller === "object") {
      const stringKeys = ["name", "label", "display", "controller", "value"];
      for (const key of stringKeys) {
        if (typeof controller[key] === "string" && controller[key].trim()) {
          const parsed = parseController(controller[key]);
          if (parsed.controlled) return parsed;
        }
      }
      const numberKeys = ["player", "player_num", "player_number", "playerId", "player_id", "id", "value"];
      for (const key of numberKeys) {
        if (typeof controller[key] === "number" && Number.isFinite(controller[key])) {
          const n = Math.max(0, Math.floor(controller[key]));
          if (n > 0) return { controlled: true, playerNum: n, label: `Player ${n}` };
        }
      }
    }

    return uncontrolled;
  }

  // Default terrain palette for hex maps - cartography style matching city maps
  const DEFAULT_TERRAIN = {
    "water":       { fill:"#9a9a8a" },
    "rocks":       { fill:"#b8b4a4" },
    "swamp":       { fill:"#a8b098" },
    "forest-light":{ fill:"#b8c4a8" },
    "forest-dark": { fill:"#98a888" },
    "mountain":    { fill:"#c8c4b8" },
    "plain":       { fill:"#e8e4d4" },
    "hill":        { fill:"#d8d4c4" },
    "desert":      { fill:"#e0d8c0" },
    "unknown":     { fill:"#d0ccc0" }
  };

  function getTerrainColor(terrain) {
    if (customColors[terrain]) return customColors[terrain];
    return (DEFAULT_TERRAIN[terrain] || DEFAULT_TERRAIN.unknown).fill;
  }

  const HEX_COLORS = {
    background: "#9a9a8a",
    grid: "rgba(60, 55, 45, 0.15)",
    townFill: "#c8c4b4",
    townStroke: "#5a5a4a",
    dangerFill: "#a08070",
    dangerStroke: "#5a4a3a",
    label: "rgba(40, 35, 25, 0.85)",
  };

  const CITY_COLORS = {
    background: "#8a8a7a",
    water: "#8a8a7a",
    earth: "#e8e4d4",
    terrainMountain: "#7f7a70",
    terrainHill: "#9a9383",
    terrainPlain: "#aaa38f",
    building: "#c8c4b4",
    buildingStroke: "#7a7a6a",
    buildingSelected: "#e8a060",
    wall: "#1a1a1a",
    road: "#d8d4c4",
    roadStroke: "#9a9a8a",
    district: "#4a4a3a",
    river: "#6f8fa8",
    green: "#a8b898",
    field: "#c8d4b8",
    tree: "#6a7a5a",
    grid: "rgba(0,0,0,0.08)",
  };
  const CITY_RENDER = {
    showWalls: false,
  };

  // District color palette for game squares
  const DISTRICT_COLORS = [
    "#4a90a4", "#8a6a4a", "#6a8a5a", "#9a6a7a", "#7a7a4a",
    "#5a7a8a", "#8a5a6a", "#6a6a8a", "#7a8a6a", "#8a7a5a", "#5a8a7a"
  ];

  function getDistrictSquareColor(districtIndex) {
    return DISTRICT_COLORS[districtIndex % DISTRICT_COLORS.length];
  }

  function adjustAlpha(hexColor, alpha) {
    const r = parseInt(hexColor.slice(1, 3), 16);
    const g = parseInt(hexColor.slice(3, 5), 16);
    const b = parseInt(hexColor.slice(5, 7), 16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
  }

  // Building selection state
  let selectedBuildingIndex = null;
  let buildingData = {};

  // Editing tools
  let activeTool = null; // null | "move_building" | "rotate_building" | "add_road"
  let dragBuilding = null; // { index, lastWorldX, lastWorldY }
  let rotateBuilding = null; // { index, center:[x,y], lastAngle }
  let roadDraft = null; // { start:[x,y], end:[x,y] }

  // --- Hex math (odd-q offset) ---
  const SQRT3 = Math.sqrt(3);

  function hexToPixel(q, r) {
    const x = hexSize * 1.5 * q;
    const y = hexSize * SQRT3 * (r + 0.5 * (q & 1));
    return { x, y };
  }

  function hexPolygon(cx, cy) {
    const pts = [];
    for (let i = 0; i < 6; i++) {
      const a = (Math.PI / 180) * (60 * i);
      pts.push({ x: cx + hexSize * Math.cos(a), y: cy + hexSize * Math.sin(a) });
    }
    return pts;
  }

  function drawPoly(pts) {
    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
    ctx.closePath();
  }

  function pointInPoly(px, py, pts) {
    let inside = false;
    for (let i = 0, j = pts.length - 1; i < pts.length; j = i++) {
      const xi = pts[i].x, yi = pts[i].y;
      const xj = pts[j].x, yj = pts[j].y;
      const intersect = ((yi > py) !== (yj > py)) &&
        (px < (xj - xi) * (py - yi) / (yj - yi + 1e-12) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  function resize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.floor(canvas.clientWidth * dpr);
    canvas.height = Math.floor(canvas.clientHeight * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    render();
  }

  // --- Hex map functions ---
  function computeHexBounds() {
    let minQ = Infinity, maxQ = -Infinity, minR = Infinity, maxR = -Infinity;
    for (const k in map.hexes) {
      const h = map.hexes[k];
      if (typeof h.q !== "number" || typeof h.r !== "number") continue;
      minQ = Math.min(minQ, h.q); maxQ = Math.max(maxQ, h.q);
      minR = Math.min(minR, h.r); maxR = Math.max(maxR, h.r);
    }
    return { minQ, maxQ, minR, maxR };
  }

  function rebuildHitIndex() {
    hitIndex = [];
    for (const k in map.hexes) {
      const h = map.hexes[k];
      if (typeof h.q !== "number" || typeof h.r !== "number") continue;
      const {x, y} = hexToPixel(h.q, h.r);
      const poly = hexPolygon(x, y);
      hitIndex.push({ q:h.q, r:h.r, cx:x, cy:y, poly, hexObj:h });
    }
  }

  function fitHexToScreen() {
    if (!map || !map.hexes) return;
    bounds = computeHexBounds();
    const corners = [];
    for (let q of [bounds.minQ, bounds.maxQ]) {
      for (let r of [bounds.minR, bounds.maxR]) {
        corners.push(hexToPixel(q, r));
      }
    }
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    for (const p of corners) {
      minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
      minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y);
    }
    minX -= hexSize; maxX += hexSize;
    minY -= hexSize; maxY += hexSize;

    const w = canvas.clientWidth, h = canvas.clientHeight;
    const scaleX = w / (maxX - minX);
    const scaleY = h / (maxY - minY);
    zoom = Math.min(scaleX, scaleY) * 0.95;
    panX = (w / 2) - zoom * ((minX + maxX) / 2);
    panY = (h / 2) - zoom * ((minY + maxY) / 2);
  }

  // --- City map functions ---
  function parseCityMap(data) {
    const result = {
      values: null, earth: null, terrain: [], water: [], roads: [], walls: [], rivers: [], river_islands: [],
      planks: [], buildings: [], prisms: [], squares: [], greens: [], fields: [],
      trees: [], districts: [],
      bounds: { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity },
      name: null
    };

    for (const feature of data.features) {
      const id = feature.id;
      if (id === "values") { result.values = feature; if (feature.name) result.name = feature.name; continue; }

      const updateBounds = (coords) => {
        if (!coords) return;
        if (typeof coords[0] === "number") {
          result.bounds.minX = Math.min(result.bounds.minX, coords[0]);
          result.bounds.maxX = Math.max(result.bounds.maxX, coords[0]);
          result.bounds.minY = Math.min(result.bounds.minY, coords[1]);
          result.bounds.maxY = Math.max(result.bounds.maxY, coords[1]);
        } else { for (const c of coords) updateBounds(c); }
      };

      if (feature.coordinates) updateBounds(feature.coordinates);
      if (feature.geometries) { for (const geom of feature.geometries) { if (geom.coordinates) updateBounds(geom.coordinates); } }

      switch (id) {
        case "earth": result.earth = feature.coordinates; break;
        case "terrain": result.terrain = feature.geometries || []; break;
        case "water": result.water = feature.coordinates || []; break;
        case "roads": result.roads = feature.geometries || []; break;
        case "walls": result.walls = feature.geometries || []; break;
        case "rivers": result.rivers = feature.geometries || []; break;
        case "river_islands": result.river_islands = feature.coordinates || []; break;
        case "planks": result.planks = feature.geometries || []; break;
        case "buildings": result.buildings = feature.coordinates || []; break;
        case "prisms": result.prisms = feature.coordinates || []; break;
        case "squares": result.squares = feature.coordinates || []; break;
        case "greens": result.greens = feature.coordinates || []; break;
        case "fields": result.fields = feature.coordinates || []; break;
        case "trees": result.trees = feature.geometries || feature.coordinates || []; break;
        case "districts": result.districts = feature.geometries || []; break;
      }
    }
    return result;
  }

  // Calculate polygon area using shoelace formula
  function polygonArea(coords) {
    if (!coords || coords.length < 2) return 0;
    const ring = coords[0];
    if (!ring || ring.length < 3) return 0;
    let area = 0;
    for (let i = 0; i < ring.length - 1; i++) {
      area += ring[i][0] * ring[i + 1][1];
      area -= ring[i + 1][0] * ring[i][1];
    }
    return Math.abs(area / 2);
  }

  // Area of a flat ring (not wrapped in array)
  function ringArea(ring) {
    if (!ring || ring.length < 3) return 0;
    let area = 0;
    for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
      area += ring[j][0] * ring[i][1];
      area -= ring[i][0] * ring[j][1];
    }
    return Math.abs(area / 2);
  }

  // Point in polygon test for city buildings
  function pointInBuildingPoly(x, y, coords) {
    if (!coords || coords.length === 0) return false;
    const ring = coords[0];
    if (!ring || ring.length < 3) return false;
    let inside = false;
    for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
      const xi = ring[i][0], yi = ring[i][1];
      const xj = ring[j][0], yj = ring[j][1];
      const intersect = ((yi > y) !== (yj > y)) &&
        (x < (xj - xi) * (y - yi) / (yj - yi + 1e-12) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  // Point in polygon test for a flat ring [[x,y], ...]
  function pointInRing(x, y, ring) {
    if (!ring || ring.length < 3) return false;
    let inside = false;
    for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
      const xi = ring[i][0], yi = ring[i][1];
      const xj = ring[j][0], yj = ring[j][1];
      const intersect = ((yi > y) !== (yj > y)) &&
        (x < (xj - xi) * (y - yi) / (yj - yi + 1e-12) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  // Find building at world coordinates
  function findBuildingAtWorld(x, y) {
    if (!cityData || !cityData.buildings) return null;
    for (let i = cityData.buildings.length - 1; i >= 0; i--) {
      if (pointInBuildingPoly(x, y, cityData.buildings[i])) return i;
    }
    return null;
  }

  function buildingCenter(building) {
    const ring = building && building[0];
    if (!ring || ring.length === 0) return [0, 0];
    let cx = 0, cy = 0;
    for (const p of ring) { cx += p[0]; cy += p[1]; }
    return [cx / ring.length, cy / ring.length];
  }

  function moveBuilding(index, dx, dy) {
    const building = cityData?.buildings?.[index];
    if (!building) return;
    for (const ring of building) {
      for (const p of ring) {
        p[0] += dx;
        p[1] += dy;
      }
    }
  }

  function rotateBuildingBy(index, center, angleRad) {
    const building = cityData?.buildings?.[index];
    if (!building) return;
    const cosA = Math.cos(angleRad);
    const sinA = Math.sin(angleRad);
    const cx = center[0], cy = center[1];
    for (const ring of building) {
      for (const p of ring) {
        const dx = p[0] - cx;
        const dy = p[1] - cy;
        p[0] = cx + dx * cosA - dy * sinA;
        p[1] = cy + dx * sinA + dy * cosA;
      }
    }
  }

  function refreshSquareBuildingAssignments() {
    if (!showGameSquares || !gameSquares || gameSquares.length === 0 || !cityData?.buildings) return;
    for (const sq of gameSquares) {
      sq.buildingIndices = [];
      sq.buildingCount = 0;
    }
    for (let bi = 0; bi < cityData.buildings.length; bi++) {
      const c = buildingCenter(cityData.buildings[bi]);
      for (const sq of gameSquares) {
        if (pointInRing(c[0], c[1], sq.polygon)) {
          sq.buildingIndices.push(bi);
          sq.buildingCount += 1;
          break;
        }
      }
    }
  }

  function setActiveTool(toolName) {
    activeTool = activeTool === toolName ? null : toolName;
    dragBuilding = null;
    rotateBuilding = null;
    roadDraft = null;
    isPanning = false;
    const btnMove = document.getElementById("editMoveBuildingsBtn");
    const btnRotate = document.getElementById("editRotateBuildingsBtn");
    const btnRoad = document.getElementById("editAddRoadBtn");
    if (btnMove) btnMove.classList.toggle("active", activeTool === "move_building");
    if (btnRotate) btnRotate.classList.toggle("active", activeTool === "rotate_building");
    if (btnRoad) btnRoad.classList.toggle("active", activeTool === "add_road");
    syncEditPanelToggleButtons();
    canvas.style.cursor = activeTool ? "crosshair" : "default";
    render();
  }

  function syncEditPanelToggleButtons() {
    const gridBtn = document.getElementById("editToggleGridBtn");
    const labelsBtn = document.getElementById("editToggleLabelsBtn");
    if (gridBtn) {
      gridBtn.classList.toggle("active", !!showGrid);
      gridBtn.textContent = showGrid ? "Grid: On" : "Grid: Off";
    }
    if (labelsBtn) {
      labelsBtn.classList.toggle("active", !!showLabels);
      labelsBtn.textContent = showLabels ? "Labels: On" : "Labels: Off";
    }
  }

  function setEditPanelVisible(visible) {
    const panel = document.getElementById("editToolsPanel");
    const btn = document.getElementById("editMapBtn");
    if (!panel || !btn) return;
    panel.classList.toggle("visible", !!visible);
    btn.classList.toggle("active", !!visible);
    if (visible) syncEditPanelToggleButtons();
  }

  function duplicateSelectedBuilding() {
    if (!cityData?.buildings || selectedBuildingIndex === null) {
      alert("Select a building first, then click Duplicate Building.");
      return;
    }
    const src = cityData.buildings[selectedBuildingIndex];
    if (!src) return;

    const copy = src.map(ring => ring.map(p => [p[0], p[1]]));
    const c = buildingCenter(copy);
    const earthRing = cityData?.earth?.[0];

    // Default offset to southeast; if outside earth, flip direction.
    let dx = 22, dy = 22;
    if (earthRing && !pointInRing(c[0] + dx, c[1] + dy, earthRing)) {
      dx = -22; dy = -22;
      if (!pointInRing(c[0] + dx, c[1] + dy, earthRing)) {
        dx = 0; dy = 26;
      }
    }
    for (const ring of copy) {
      for (const p of ring) {
        p[0] += dx;
        p[1] += dy;
      }
    }

    cityData.buildings.push(copy);
    const newIdx = cityData.buildings.length - 1;

    if (buildingData[selectedBuildingIndex]) {
      const srcData = JSON.parse(JSON.stringify(buildingData[selectedBuildingIndex]));
      if (srcData.name) srcData.name = `${srcData.name} Copy`;
      buildingData[newIdx] = srcData;
    }

    selectedBuildingIndex = newIdx;
    refreshSquareBuildingAssignments();
    showBuildingPanel(newIdx);
    document.getElementById("export").style.display = "inline-block";
    render();
  }

  // =============================================
  // GAME SQUARES - Utility Functions
  // =============================================

  function dist(a, b) {
    const dx = a[0] - b[0], dy = a[1] - b[1];
    return Math.sqrt(dx * dx + dy * dy);
  }

  function buildingCentroid(building) {
    const ring = building[0];
    if (!ring || ring.length === 0) return [0, 0];
    let cx = 0, cy = 0;
    for (const pt of ring) { cx += pt[0]; cy += pt[1]; }
    return [cx / ring.length, cy / ring.length];
  }

  function polygonCentroid(ring) {
    if (!ring || ring.length === 0) return [0, 0];
    let cx = 0, cy = 0;
    for (const pt of ring) { cx += pt[0]; cy += pt[1]; }
    return [cx / ring.length, cy / ring.length];
  }

  // Convex hull using Andrew's monotone chain algorithm
  function convexHull(points) {
    if (points.length < 3) return points.slice();
    const pts = points.slice().sort((a, b) => a[0] - b[0] || a[1] - b[1]);

    function cross(o, a, b) {
      return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
    }

    const lower = [];
    for (const p of pts) {
      while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) lower.pop();
      lower.push(p);
    }

    const upper = [];
    for (let i = pts.length - 1; i >= 0; i--) {
      const p = pts[i];
      while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) upper.pop();
      upper.push(p);
    }

    lower.pop();
    upper.pop();
    return lower.concat(upper);
  }

  // Buffer a polygon outward (positive) or inward (negative) by a given distance
  function bufferPolygon(ring, amount) {
    if (!ring || ring.length < 3) return ring;
    const centroid = polygonCentroid(ring);
    return ring.map(pt => {
      const dx = pt[0] - centroid[0];
      const dy = pt[1] - centroid[1];
      const d = Math.sqrt(dx * dx + dy * dy);
      if (d < 0.001) return pt;
      const scale = (d + amount) / d;
      return [centroid[0] + dx * scale, centroid[1] + dy * scale];
    });
  }

  // Clip a polygon by a half-plane defined by a line from A to B.
  // Keeps the side where points are to the LEFT of the line A->B.
  // (Sutherland-Hodgman single-edge clip)
  function clipPolygonByLine(polygon, ax, ay, bx, by) {
    if (!polygon || polygon.length < 3) return polygon;
    const output = [];
    const n = polygon.length;

    for (let i = 0; i < n; i++) {
      const curr = polygon[i];
      const next = polygon[(i + 1) % n];

      const currSide = (bx - ax) * (curr[1] - ay) - (by - ay) * (curr[0] - ax);
      const nextSide = (bx - ax) * (next[1] - ay) - (by - ay) * (next[0] - ax);

      if (currSide >= 0) {
        // Current point is inside
        output.push(curr);
        if (nextSide < 0) {
          // Next is outside, add intersection
          const inter = lineIntersect(curr[0], curr[1], next[0], next[1], ax, ay, bx, by);
          if (inter) output.push(inter);
        }
      } else {
        // Current point is outside
        if (nextSide >= 0) {
          // Next is inside, add intersection
          const inter = lineIntersect(curr[0], curr[1], next[0], next[1], ax, ay, bx, by);
          if (inter) output.push(inter);
        }
      }
    }
    return output;
  }

  // Line-line intersection (segments treated as infinite lines)
  function lineIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
    const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    if (Math.abs(denom) < 1e-10) return null;
    const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
    return [x1 + t * (x2 - x1), y1 + t * (y2 - y1)];
  }

  // Generate Voronoi-like cell for a partition within a district polygon.
  // Clips the district polygon using perpendicular bisectors between this
  // partition's centroid and every other partition's centroid.
  // The result is the region of the district closer to this centroid than any other.
  function voronoiCell(districtRing, myCentroid, otherCentroids) {
    let cell = districtRing.slice();

    for (const other of otherCentroids) {
      if (cell.length < 3) break;

      // Midpoint between the two centroids
      const mx = (myCentroid[0] + other[0]) / 2;
      const my = (myCentroid[1] + other[1]) / 2;

      // Direction perpendicular to the line between centroids
      // The bisector line goes through (mx, my) perpendicular to (my -> other)
      const dx = other[0] - myCentroid[0];
      const dy = other[1] - myCentroid[1];

      // Two points on the bisector line: perpendicular direction is (-dy, dx)
      // We want to keep the side containing myCentroid (left side of line A->B)
      const ax = mx - dy;
      const ay = my + dx;
      const bx = mx + dy;
      const by = my - dx;

      // Determine which direction keeps myCentroid
      const mySide = (bx - ax) * (myCentroid[1] - ay) - (by - ay) * (myCentroid[0] - ax);
      if (mySide >= 0) {
        cell = clipPolygonByLine(cell, ax, ay, bx, by);
      } else {
        // Flip the line direction
        cell = clipPolygonByLine(cell, bx, by, ax, ay);
      }
    }

    return cell;
  }

  // Calculate bounding box for a ring
  function ringBounds(ring) {
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    for (const pt of ring) {
      if (pt[0] < minX) minX = pt[0];
      if (pt[0] > maxX) maxX = pt[0];
      if (pt[1] < minY) minY = pt[1];
      if (pt[1] > maxY) maxY = pt[1];
    }
    return { minX, maxX, minY, maxY };
  }

  // Signed distance from point to line segment (positive = left side, negative = right side)
  function signedDistToSegment(px, py, ax, ay, bx, by) {
    return (bx - ax) * (py - ay) - (by - ay) * (px - ax);
  }

  // =============================================
  // GAME SQUARES - Generation Algorithm
  // =============================================

  function assignBuildingsToDistricts() {
    const districtBuildings = new Map();
    for (let di = 0; di < cityData.districts.length; di++) {
      districtBuildings.set(di, []);
    }

    for (let bi = 0; bi < cityData.buildings.length; bi++) {
      const centroid = buildingCentroid(cityData.buildings[bi]);
      let found = false;

      for (let di = 0; di < cityData.districts.length; di++) {
        const dRing = cityData.districts[di].coordinates[0];
        if (pointInRing(centroid[0], centroid[1], dRing)) {
          districtBuildings.get(di).push(bi);
          found = true;
          break;
        }
      }

      // If not in any district, assign to nearest
      if (!found) {
        let minDist = Infinity;
        let nearestDi = 0;
        for (let di = 0; di < cityData.districts.length; di++) {
          const dc = polygonCentroid(cityData.districts[di].coordinates[0]);
          const d = dist(centroid, dc);
          if (d < minDist) { minDist = d; nearestDi = di; }
        }
        districtBuildings.get(nearestDi).push(bi);
      }
    }
    return districtBuildings;
  }

  function extractDistrictRoads(districtIndex) {
    const dRing = cityData.districts[districtIndex].coordinates[0];
    const roads = [];

    for (const road of cityData.roads) {
      if (!road.coordinates || road.coordinates.length < 2) continue;
      const coords = road.coordinates;
      // Check if road midpoint is within district
      const midIdx = Math.floor(coords.length / 2);
      const mid = coords[midIdx];
      if (pointInRing(mid[0], mid[1], dRing)) {
        // Calculate road length
        let len = 0;
        for (let i = 1; i < coords.length; i++) {
          len += dist(coords[i - 1], coords[i]);
        }
        roads.push({ coordinates: coords, width: road.width || 8, length: len });
      }
    }

    return roads;
  }

  // Partition buildings using roads as dividers
  function partitionByRoads(buildingIndices, roads, targetCount) {
    if (roads.length < 2 || buildingIndices.length < targetCount) return null;

    // Sort roads by length (longest first) and pick the most significant ones
    const sorted = roads.slice().sort((a, b) => b.length - a.length);
    // Use up to targetCount-1 dividing roads (each road splits space further)
    const dividers = sorted.slice(0, Math.min(sorted.length, targetCount + 2));

    // For each building, create a signature based on which side of each divider road it falls on
    const buildingCentroids = buildingIndices.map(bi => buildingCentroid(cityData.buildings[bi]));
    const signatures = new Map();

    for (let i = 0; i < buildingIndices.length; i++) {
      const [bx, by] = buildingCentroids[i];
      let sig = "";

      for (const road of dividers) {
        const coords = road.coordinates;
        // Use the first and last point of the road as a line
        const ax = coords[0][0], ay = coords[0][1];
        const bxr = coords[coords.length - 1][0], byr = coords[coords.length - 1][1];
        const side = signedDistToSegment(bx, by, ax, ay, bxr, byr);
        sig += side >= 0 ? "L" : "R";
      }

      if (!signatures.has(sig)) signatures.set(sig, []);
      signatures.get(sig).push(buildingIndices[i]);
    }

    let partitions = Array.from(signatures.values());

    // If we got too many tiny partitions, merge small ones
    partitions = mergeSmallPartitions(partitions, buildingIndices, targetCount);

    // If we didn't get enough partitions, fall back
    if (partitions.length < 3) return null;

    return partitions;
  }

  function mergeSmallPartitions(partitions, allBuildingIndices, targetCount) {
    const minSize = Math.max(3, Math.floor(allBuildingIndices.length / (targetCount * 3)));

    // Separate into viable and small
    let viable = [];
    let small = [];
    for (const p of partitions) {
      if (p.length >= minSize) viable.push(p);
      else small.push(p);
    }

    // Merge small partitions into nearest viable one
    for (const sp of small) {
      if (sp.length === 0) continue;
      const spCentroid = avgCentroid(sp);

      if (viable.length === 0) {
        viable.push(sp);
        continue;
      }

      let minD = Infinity, nearest = 0;
      for (let i = 0; i < viable.length; i++) {
        const vc = avgCentroid(viable[i]);
        const d = dist(spCentroid, vc);
        if (d < minD) { minD = d; nearest = i; }
      }
      viable[nearest] = viable[nearest].concat(sp);
    }

    // If still too many, merge closest pairs
    while (viable.length > targetCount + 2) {
      let minD = Infinity, mergeA = 0, mergeB = 1;
      for (let i = 0; i < viable.length; i++) {
        for (let j = i + 1; j < viable.length; j++) {
          const d = dist(avgCentroid(viable[i]), avgCentroid(viable[j]));
          if (d < minD) { minD = d; mergeA = i; mergeB = j; }
        }
      }
      viable[mergeA] = viable[mergeA].concat(viable[mergeB]);
      viable.splice(mergeB, 1);
    }

    return viable;
  }

  function avgCentroid(buildingIndices) {
    let cx = 0, cy = 0;
    for (const bi of buildingIndices) {
      const c = buildingCentroid(cityData.buildings[bi]);
      cx += c[0]; cy += c[1];
    }
    return [cx / buildingIndices.length, cy / buildingIndices.length];
  }

  // K-means clustering fallback
  function partitionByClustering(buildingIndices, targetCount) {
    const k = Math.min(targetCount, buildingIndices.length);
    if (k <= 1) return [buildingIndices];

    const centroids_arr = buildingIndices.map(bi => buildingCentroid(cityData.buildings[bi]));

    // K-means++ initialization
    let centers = [];
    const firstIdx = Math.floor(Math.random() * centroids_arr.length);
    centers.push(centroids_arr[firstIdx].slice());

    for (let c = 1; c < k; c++) {
      const dists = centroids_arr.map(p => {
        let minD = Infinity;
        for (const center of centers) {
          const d = dist(p, center);
          if (d < minD) minD = d;
        }
        return minD * minD;
      });
      const total = dists.reduce((s, d) => s + d, 0);
      let r = Math.random() * total;
      for (let i = 0; i < dists.length; i++) {
        r -= dists[i];
        if (r <= 0) { centers.push(centroids_arr[i].slice()); break; }
      }
      if (centers.length <= c) centers.push(centroids_arr[c % centroids_arr.length].slice());
    }

    // Iterate
    let assignments = new Array(centroids_arr.length).fill(0);
    for (let iter = 0; iter < 50; iter++) {
      // Assign
      let changed = false;
      for (let i = 0; i < centroids_arr.length; i++) {
        let minD = Infinity, minC = 0;
        for (let c = 0; c < k; c++) {
          const d = dist(centroids_arr[i], centers[c]);
          if (d < minD) { minD = d; minC = c; }
        }
        if (assignments[i] !== minC) { assignments[i] = minC; changed = true; }
      }

      if (!changed) break;

      // Update centers
      for (let c = 0; c < k; c++) {
        let sx = 0, sy = 0, count = 0;
        for (let i = 0; i < centroids_arr.length; i++) {
          if (assignments[i] === c) {
            sx += centroids_arr[i][0]; sy += centroids_arr[i][1]; count++;
          }
        }
        if (count > 0) centers[c] = [sx / count, sy / count];
      }
    }

    // Collect partitions
    const partitions = Array.from({ length: k }, () => []);
    for (let i = 0; i < buildingIndices.length; i++) {
      partitions[assignments[i]].push(buildingIndices[i]);
    }

    return partitions.filter(p => p.length > 0);
  }

  // Main game squares generation function
  function generateGameSquares(targetPerDistrict = 7, boardState = null) {
    if (!cityData || !cityData.districts || cityData.districts.length === 0) return [];

    console.log("Generating game squares...");
    const squares = [];
    const districtBuildings = assignBuildingsToDistricts();

    // Build per-district target map from board state
    const boardStateTargets = {};
    if (boardState) {
      const districts = boardState.districts || {};
      for (const [dName, dData] of Object.entries(districts)) {
        const squareCount = Object.keys(dData.squares || {}).length;
        boardStateTargets[dName.toLowerCase()] = squareCount;
      }
      console.log("  Board state targets:", boardStateTargets);
    }

    // Calculate average district area for scaling
    let totalArea = 0;
    const districtAreas = [];
    for (let di = 0; di < cityData.districts.length; di++) {
      const a = ringArea(cityData.districts[di].coordinates[0]);
      districtAreas.push(a);
      totalArea += a;
    }
    const avgArea = totalArea / cityData.districts.length;

    // Gap size between squares (inward shrink amount)
    const gapSize = 5;

    for (let di = 0; di < cityData.districts.length; di++) {
      const district = cityData.districts[di];
      const districtRing = district.coordinates[0];
      const buildingIndices = districtBuildings.get(di);

      if (!buildingIndices || buildingIndices.length === 0) {
        console.log(`  ${district.name}: no buildings, skipping`);
        continue;
      }

      // Determine target: board state override or area-scaled default
      let target;
      const distNameLower = (district.name || "").toLowerCase();
      if (boardState && boardStateTargets[distNameLower] !== undefined) {
        target = boardStateTargets[distNameLower];
      } else {
        const areaRatio = districtAreas[di] / avgArea;
        target = Math.round(targetPerDistrict * Math.sqrt(areaRatio));
        target = Math.max(2, Math.min(10, target));
      }

      // For very few buildings, reduce target
      if (buildingIndices.length < target * 3) {
        target = Math.max(1, Math.floor(buildingIndices.length / 3));
      }

      // Get roads for this district
      const roads = extractDistrictRoads(di);

      // Try road-based partitioning first
      let partitions = null;
      if (roads.length >= 3) {
        partitions = partitionByRoads(buildingIndices, roads, target);
      }

      // Fall back to clustering
      if (!partitions || partitions.length < 2) {
        partitions = partitionByClustering(buildingIndices, target);
      }

      console.log(`  ${district.name}: ${buildingIndices.length} buildings -> ${partitions.length} squares (target: ${target}, roads: ${roads.length})`);

      // Compute centroid for each partition
      const partitionCentroids = partitions.map(p => avgCentroid(p));

      // Generate non-overlapping Voronoi cells within the district polygon
      for (let si = 0; si < partitions.length; si++) {
        const partition = partitions[si];
        if (partition.length === 0) continue;

        const myCentroid = partitionCentroids[si];
        const otherCentroids = partitionCentroids.filter((_, idx) => idx !== si);

        // Compute the Voronoi cell: the region of the district closer to
        // this partition's centroid than any other
        let cell = voronoiCell(districtRing, myCentroid, otherCentroids);

        if (!cell || cell.length < 3) continue;

        // Shrink the cell inward slightly to create gaps between squares
        cell = bufferPolygon(cell, -gapSize);

        if (!cell || cell.length < 3) continue;

        const centroid = polygonCentroid(cell);
        const area = ringArea(cell);
        const bounds = ringBounds(cell);

        squares.push({
          id: `gs_${di}_${si}`,
          name: `${district.name} ${String.fromCharCode(65 + si)}`,
          districtIndex: di,
          districtName: district.name,
          polygon: cell,
          centroid,
          area,
          bounds,
          buildingIndices: partition,
          buildingCount: partition.length,
          generationType: roads.length >= 3 ? "road_block" : "cluster",
          notes: "",
          color: null
        });
      }
    }

    console.log(`Generated ${squares.length} total game squares across ${cityData.districts.length} districts`);

    // Map squares to board state data if available
    if (boardState) {
      mapSquaresToBoardState(squares, boardState);
    }

    return squares;
  }

  // Map generated game squares to board state square data
  function mapSquaresToBoardState(squares, boardState) {
    if (!boardState || !boardState.districts) return;

    // Group squares by district name
    const byDistrict = {};
    for (const sq of squares) {
      const dName = sq.districtName;
      if (!byDistrict[dName]) byDistrict[dName] = [];
      byDistrict[dName].push(sq);
    }

    // For each district, sort squares by position (left-to-right, top-to-bottom)
    // and match to board state squares in order
    for (const [dName, dSquares] of Object.entries(byDistrict)) {
      // Sort by centroid: primarily by Y (top-to-bottom), then by X (left-to-right)
      dSquares.sort((a, b) => {
        const yDiff = a.centroid[1] - b.centroid[1];
        if (Math.abs(yDiff) > 50) return yDiff;
        return a.centroid[0] - b.centroid[0];
      });

      // Find matching board state district
      const bsDistrict = boardState.districts[dName.toLowerCase()] || boardState.districts[dName];
      if (!bsDistrict) continue;

      const bsSquares = bsDistrict.squares || {};
      const squareIds = Object.keys(bsSquares);

      // Map each generated square to a board state square
      for (let i = 0; i < dSquares.length; i++) {
        if (i < squareIds.length) {
          const sqId = squareIds[i];
          const bsSq = bsSquares[sqId];
          dSquares[i].boardStateId = sqId;
          dSquares[i].boardState = bsSq;
          dSquares[i].boardStateDistrict = {
            total_vp: bsDistrict.total_vp,
            district_controller: bsDistrict.district_controller,
            linked_faction: bsDistrict.linked_faction,
            linked_coterie: bsDistrict.linked_coterie,
            special_ability: bsDistrict.special_ability,
          };
          // Use board state square name if available
          if (bsSq.name) {
            dSquares[i].name = bsSq.name;
          }
        }
      }
    }

    const mapped = squares.filter(sq => sq.boardState).length;
    console.log(`  Mapped ${mapped}/${squares.length} squares to board state data`);
  }

  // Find game square at world coordinates
  function findSquareAtWorld(x, y) {
    for (let i = gameSquares.length - 1; i >= 0; i--) {
      const sq = gameSquares[i];
      if (x < sq.bounds.minX || x > sq.bounds.maxX ||
          y < sq.bounds.minY || y > sq.bounds.maxY) continue;
      if (pointInRing(x, y, sq.polygon)) return i;
    }
    return null;
  }

  // =============================================
  // Dwelling generation (unchanged from viewer.html)
  // =============================================

  function generateDwelling(buildingIndex) {
    if (!cityData || !cityData.buildings[buildingIndex]) return null;
    const building = cityData.buildings[buildingIndex];
    const area = polygonArea(building);
    let numFloors;
    if (area < 200) { numFloors = Math.random() < 0.7 ? 1 : 2; }
    else if (area < 500) { numFloors = Math.random() < 0.5 ? 2 : 3; }
    else if (area < 1000) { numFloors = 2 + Math.floor(Math.random() * 2); }
    else { numFloors = 3 + Math.floor(Math.random() * 2); }
    const hasBasement = area > 300 && Math.random() < 0.4;
    const gridSize = Math.max(3, Math.min(7, Math.ceil(Math.sqrt(area / 50))));
    const floors = [];
    const startLevel = hasBasement ? -1 : 0;
    for (let level = startLevel; level < numFloors; level++) {
      floors.push(generateFloor(level, gridSize, level === startLevel));
    }
    connectFloors(floors);
    const groundFloor = floors.find(f => f.level === 0);
    const exitCell = groundFloor ? groundFloor.rooms[0]?.cells[0] : { i: 0, j: 0 };
    return { floors, exit: { cell: exitCell || { i: 0, j: 0 }, dir: "n" } };
  }

  function generateFloor(level, gridSize, isBottom) {
    const floor = { level, rooms: [], doors: [], windows: [], stairs: [] };
    const cells = [];
    for (let i = 0; i < gridSize; i++) { cells[i] = []; for (let j = 0; j < gridSize; j++) cells[i][j] = null; }

    const roomTypes = level === -1 ? ["Cellar", "Storage", "Vault"]
      : level === 0 ? ["Hall", "Kitchen", "Living room", "Study", "Workshop"]
      : ["Bedroom", "Room", "Bathroom", "Library"];

    let roomIndex = 0;
    const numRooms = Math.max(1, Math.min(5, Math.floor(gridSize * gridSize / 4)));

    const mainRoom = { name: roomTypes[Math.floor(Math.random() * roomTypes.length)], cells: [] };
    const startI = Math.floor(Math.random() * (gridSize - 1));
    const startJ = Math.floor(Math.random() * (gridSize - 1));
    const roomSize = 2 + Math.floor(Math.random() * 3);
    const queue = [{ i: startI, j: startJ }];
    const visited = new Set();

    while (queue.length > 0 && mainRoom.cells.length < roomSize) {
      const { i, j } = queue.shift();
      const key = `${i},${j}`;
      if (visited.has(key) || i < 0 || i >= gridSize || j < 0 || j >= gridSize) continue;
      if (cells[i][j] !== null) continue;
      visited.add(key);
      mainRoom.cells.push({ i, j });
      cells[i][j] = roomIndex;
      const neighbors = [{ i: i-1, j }, { i: i+1, j }, { i, j: j-1 }, { i, j: j+1 }].sort(() => Math.random() - 0.5);
      for (const n of neighbors) queue.push(n);
    }
    floor.rooms.push(mainRoom);
    roomIndex++;

    for (let r = 1; r < numRooms; r++) {
      const room = { name: roomTypes[Math.floor(Math.random() * roomTypes.length)], cells: [] };
      let foundStart = null;
      for (let i = 0; i < gridSize && !foundStart; i++) {
        for (let j = 0; j < gridSize && !foundStart; j++) {
          if (cells[i][j] === null) {
            const hasNeighbor = [[i-1,j],[i+1,j],[i,j-1],[i,j+1]].some(([ni,nj]) =>
              ni >= 0 && ni < gridSize && nj >= 0 && nj < gridSize && cells[ni][nj] !== null);
            if (hasNeighbor && Math.random() < 0.5) foundStart = { i, j };
          }
        }
      }
      if (!foundStart) continue;
      const size = 1 + Math.floor(Math.random() * 3);
      const q = [foundStart]; const v = new Set();
      while (q.length > 0 && room.cells.length < size) {
        const { i, j } = q.shift(); const key = `${i},${j}`;
        if (v.has(key) || i < 0 || i >= gridSize || j < 0 || j >= gridSize) continue;
        if (cells[i][j] !== null) continue;
        v.add(key); room.cells.push({ i, j }); cells[i][j] = roomIndex;
        const neighbors = [{ i: i-1, j }, { i: i+1, j }, { i, j: j-1 }, { i, j: j+1 }].sort(() => Math.random() - 0.5);
        for (const n of neighbors) q.push(n);
      }
      if (room.cells.length > 0) { floor.rooms.push(room); roomIndex++; }
    }

    for (let i = 0; i < gridSize; i++) {
      for (let j = 0; j < gridSize; j++) {
        if (cells[i][j] === null) continue;
        if (i + 1 < gridSize && cells[i+1][j] !== null && cells[i+1][j] !== cells[i][j]) {
          if (Math.random() < 0.6) floor.doors.push({ edge: { cell: { i, j }, dir: "s" }, type: "REGULAR" });
        }
        if (j + 1 < gridSize && cells[i][j+1] !== null && cells[i][j+1] !== cells[i][j]) {
          if (Math.random() < 0.6) floor.doors.push({ edge: { cell: { i, j }, dir: "e" }, type: "REGULAR" });
        }
      }
    }

    if (level >= 0) {
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          if (cells[i][j] === null) continue;
          if (i === 0 || cells[i-1][j] === null) { if (Math.random() < 0.5) floor.windows.push({ cell: { i, j }, dir: "n" }); }
          if (i === gridSize-1 || cells[i+1][j] === null) { if (Math.random() < 0.5) floor.windows.push({ cell: { i, j }, dir: "s" }); }
          if (j === 0 || cells[i][j-1] === null) { if (Math.random() < 0.5) floor.windows.push({ cell: { i, j }, dir: "w" }); }
          if (j === gridSize-1 || cells[i][j+1] === null) { if (Math.random() < 0.5) floor.windows.push({ cell: { i, j }, dir: "e" }); }
        }
      }
    }
    return floor;
  }

  function connectFloors(floors) {
    for (let f = 0; f < floors.length - 1; f++) {
      const lower = floors[f], upper = floors[f + 1];
      const lowerCells = new Set();
      for (const room of lower.rooms) for (const cell of room.cells) lowerCells.add(`${cell.i},${cell.j}`);
      let stairCell = null;
      for (const room of upper.rooms) {
        for (const cell of room.cells) { if (lowerCells.has(`${cell.i},${cell.j}`)) { stairCell = { ...cell }; break; } }
        if (stairCell) break;
      }
      if (!stairCell && lower.rooms.length > 0 && upper.rooms.length > 0) stairCell = { ...lower.rooms[0].cells[0] };
      if (stairCell) {
        const dirs = ["n", "s", "e", "w"];
        const dir = dirs[Math.floor(Math.random() * dirs.length)];
        lower.stairs.push({ cell: stairCell, dir, up: true });
        upper.stairs.push({ cell: stairCell, dir, up: false });
      }
    }
  }

  function renderFloorPreview(dwelling, floorIndex) {
    const floorCanvas = document.getElementById("floorCanvas");
    if (!floorCanvas || !dwelling || !dwelling.floors[floorIndex]) return;
    const fctx = floorCanvas.getContext("2d");
    const floor = dwelling.floors[floorIndex];
    const w = floorCanvas.width, h = floorCanvas.height;
    fctx.fillStyle = "#f8f6f0"; fctx.fillRect(0, 0, w, h);

    let minI = Infinity, maxI = -Infinity, minJ = Infinity, maxJ = -Infinity;
    for (const room of floor.rooms) for (const cell of room.cells) {
      minI = Math.min(minI, cell.i); maxI = Math.max(maxI, cell.i);
      minJ = Math.min(minJ, cell.j); maxJ = Math.max(maxJ, cell.j);
    }
    if (minI === Infinity) return;

    const gridW = maxI - minI + 1, gridH = maxJ - minJ + 1;
    const cellSize = Math.min((w - 40) / gridW, (h - 40) / gridH, 30);
    const offsetX = (w - gridW * cellSize) / 2, offsetY = (h - gridH * cellSize) / 2;

    const roomColors = ["#e8e4d4", "#d8d4c4", "#c8c4b4", "#ddd8c8", "#e0dcd0"];
    for (let ri = 0; ri < floor.rooms.length; ri++) {
      const room = floor.rooms[ri]; fctx.fillStyle = roomColors[ri % roomColors.length];
      for (const cell of room.cells) { fctx.fillRect(offsetX + (cell.i - minI) * cellSize, offsetY + (cell.j - minJ) * cellSize, cellSize, cellSize); }
    }

    fctx.strokeStyle = "#3a3a2a"; fctx.lineWidth = 2;
    for (const room of floor.rooms) {
      for (const cell of room.cells) {
        const x = offsetX + (cell.i - minI) * cellSize, y = offsetY + (cell.j - minJ) * cellSize;
        const neighbors = { n: false, s: false, w: false, e: false };
        for (const r of floor.rooms) {
          if (r.cells.some(c => c.i === cell.i - 1 && c.j === cell.j)) neighbors.n = true;
          if (r.cells.some(c => c.i === cell.i + 1 && c.j === cell.j)) neighbors.s = true;
          if (r.cells.some(c => c.i === cell.i && c.j === cell.j - 1)) neighbors.w = true;
          if (r.cells.some(c => c.i === cell.i && c.j === cell.j + 1)) neighbors.e = true;
        }
        fctx.beginPath();
        if (!neighbors.n) { fctx.moveTo(x, y); fctx.lineTo(x + cellSize, y); }
        if (!neighbors.s) { fctx.moveTo(x, y + cellSize); fctx.lineTo(x + cellSize, y + cellSize); }
        if (!neighbors.w) { fctx.moveTo(x, y); fctx.lineTo(x, y + cellSize); }
        if (!neighbors.e) { fctx.moveTo(x + cellSize, y); fctx.lineTo(x + cellSize, y + cellSize); }
        fctx.stroke();
      }
    }

    fctx.strokeStyle = "#f8f6f0"; fctx.lineWidth = 4;
    for (const door of floor.doors) {
      const x = offsetX + (door.edge.cell.i - minI) * cellSize, y = offsetY + (door.edge.cell.j - minJ) * cellSize;
      const doorSize = cellSize * 0.4, center = cellSize / 2;
      fctx.beginPath();
      switch (door.edge.dir) {
        case "n": fctx.moveTo(x + center - doorSize/2, y); fctx.lineTo(x + center + doorSize/2, y); break;
        case "s": fctx.moveTo(x + center - doorSize/2, y + cellSize); fctx.lineTo(x + center + doorSize/2, y + cellSize); break;
        case "w": fctx.moveTo(x, y + center - doorSize/2); fctx.lineTo(x, y + center + doorSize/2); break;
        case "e": fctx.moveTo(x + cellSize, y + center - doorSize/2); fctx.lineTo(x + cellSize, y + center + doorSize/2); break;
      }
      fctx.stroke();
    }

    fctx.fillStyle = "#8a9aaa";
    for (const win of floor.windows) {
      const x = offsetX + (win.cell.i - minI) * cellSize, y = offsetY + (win.cell.j - minJ) * cellSize;
      const winSize = cellSize * 0.25;
      switch (win.dir) {
        case "n": fctx.fillRect(x + cellSize/2 - winSize/2, y - 2, winSize, 4); break;
        case "s": fctx.fillRect(x + cellSize/2 - winSize/2, y + cellSize - 2, winSize, 4); break;
        case "w": fctx.fillRect(x - 2, y + cellSize/2 - winSize/2, 4, winSize); break;
        case "e": fctx.fillRect(x + cellSize - 2, y + cellSize/2 - winSize/2, 4, winSize); break;
      }
    }

    fctx.fillStyle = "#5a7a4a";
    for (const stair of floor.stairs) {
      const x = offsetX + (stair.cell.i - minI) * cellSize + cellSize / 2;
      const y = offsetY + (stair.cell.j - minJ) * cellSize + cellSize / 2;
      const arrowSize = cellSize * 0.3;
      fctx.beginPath();
      if (stair.up) { fctx.moveTo(x, y - arrowSize); fctx.lineTo(x - arrowSize * 0.6, y + arrowSize * 0.3); fctx.lineTo(x + arrowSize * 0.6, y + arrowSize * 0.3); }
      else { fctx.moveTo(x, y + arrowSize); fctx.lineTo(x - arrowSize * 0.6, y - arrowSize * 0.3); fctx.lineTo(x + arrowSize * 0.6, y - arrowSize * 0.3); }
      fctx.closePath(); fctx.fill();
    }

    fctx.fillStyle = "#3a3a2a"; fctx.font = "bold 12px 'Times New Roman', Georgia, serif"; fctx.textAlign = "left";
    fctx.fillText(floor.level === -1 ? "B" : floor.level === 0 ? "GF" : `${floor.level}F`, 5, 15);
  }

  // =============================================
  // Building/Square Panel Functions
  // =============================================

  function showBuildingPanel(buildingIndex) {
    const panel = document.getElementById("buildingPanel");
    const building = cityData.buildings[buildingIndex];
    const area = polygonArea(building);
    const data = buildingData[buildingIndex] || {};

    document.getElementById("buildingTitle").textContent = `Building #${buildingIndex + 1}`;
    document.getElementById("buildingArea").textContent = `${Math.round(area)} sq units`;
    document.getElementById("buildingName").value = data.name || "";
    document.getElementById("buildingNotes").value = data.notes || "";

    const dwellingSection = document.getElementById("dwellingSection");
    if (data.dwelling) {
      dwellingSection.style.display = "block";
      updateFloorTabs(data.dwelling);
    } else {
      dwellingSection.style.display = "none";
    }
    panel.classList.add("visible");
  }

  function updateFloorTabs(dwelling) {
    const tabsContainer = document.getElementById("floorTabs");
    tabsContainer.innerHTML = "";
    dwelling.floors.forEach((floor, idx) => {
      const tab = document.createElement("button");
      tab.className = "floor-tab" + (idx === 0 ? " active" : "");
      tab.textContent = floor.level === -1 ? "B" : floor.level === 0 ? "GF" : `${floor.level}F`;
      tab.addEventListener("click", () => {
        tabsContainer.querySelectorAll(".floor-tab").forEach(t => t.classList.remove("active"));
        tab.classList.add("active");
        renderFloorPreview(dwelling, idx);
      });
      tabsContainer.appendChild(tab);
    });
    renderFloorPreview(dwelling, 0);
  }

  function hideBuildingPanel() {
    document.getElementById("buildingPanel").classList.remove("visible");
    selectedBuildingIndex = null;
    render();
  }

  function showSquarePanel(squareIndex) {
    const panel = document.getElementById("squarePanel");
    const square = gameSquares[squareIndex];

    document.getElementById("squareTitle").textContent = square.name;
    document.getElementById("squareId").textContent = square.boardStateId || square.id;
    const color = square.color || getDistrictSquareColor(square.districtIndex);
    document.getElementById("squareDistrict").innerHTML =
      `<span class="district-color" style="background:${color}"></span>${square.districtName}`;
    document.getElementById("squareBuildingCount").textContent = `${square.buildingCount} buildings`;
    document.getElementById("squareAreaInfo").textContent = `${Math.round(square.area)} sq units`;
    document.getElementById("squareName").value = square.name;
    document.getElementById("squareNotes").value = square.notes || "";

    // Board state data
    const bsSection = document.getElementById("boardStateSection");
    if (square.boardState) {
      const bs = square.boardState;
      const bsd = square.boardStateDistrict || {};

      // VP (color-coded)
      const vp = bs.vp || 0;
      const vpColor = vp > 0 ? '#44aa44' : vp < 0 ? '#cc4444' : '#888';
      document.getElementById("squareVP").innerHTML = `<span style="color:${vpColor}">${vp}</span>`;

      // Influence
      const influence = bs.influence || 0;
      document.getElementById("squareInfluence").textContent = influence;

      // Controller (color-coded)
      const controller = parseController(bs.controller);
      if (controller.controlled) {
        const pColor = PLAYER_COLORS[controller.playerNum] || '#888';
        document.getElementById("squareController").innerHTML =
          `<span style="color:${pColor};font-weight:bold">${controller.label}</span>`;
      } else {
        document.getElementById("squareController").textContent = "Uncontrolled";
      }

      // Adjacent squares
      const adjacent = bs.adjacent || [];
      if (adjacent.length > 0) {
        document.getElementById("squareAdjacent").textContent = adjacent.join(", ");
      } else {
        document.getElementById("squareAdjacent").textContent = "None";
      }

      // District info
      document.getElementById("squareDistrictVP").textContent = bsd.total_vp || "-";
      document.getElementById("squareFaction").textContent = bsd.linked_faction || "-";
      document.getElementById("squareAbility").textContent = bsd.special_ability || "-";

      bsSection.style.display = "block";
    } else {
      bsSection.style.display = "none";
    }

    panel.classList.add("visible");
  }

  function hideSquarePanel() {
    document.getElementById("squarePanel").classList.remove("visible");
    selectedSquareIndex = null;
    render();
  }

  // =============================================
  // Rendering
  // =============================================

  function fitCityToScreen() {
    if (!cityData) return;
    const { minX, maxX, minY, maxY } = cityData.bounds;
    const padding = Math.max(maxX - minX, maxY - minY) * 0.05;
    const w = canvas.clientWidth, h = canvas.clientHeight;
    const scaleX = w / (maxX - minX + padding * 2);
    const scaleY = h / (maxY - minY + padding * 2);
    zoom = Math.min(scaleX, scaleY) * 0.95;
    panX = (w / 2) - zoom * ((minX + maxX) / 2);
    panY = (h / 2) - zoom * ((minY + maxY) / 2);
  }

  function drawCoordPath(coords) {
    if (!coords || coords.length === 0) return;
    ctx.beginPath();
    ctx.moveTo(coords[0][0], coords[0][1]);
    for (let i = 1; i < coords.length; i++) ctx.lineTo(coords[i][0], coords[i][1]);
  }

  function drawPolygonCoords(coords) {
    if (!coords || coords.length === 0) return;
    ctx.beginPath();
    for (const ring of coords) {
      if (ring.length === 0) continue;
      ctx.moveTo(ring[0][0], ring[0][1]);
      for (let i = 1; i < ring.length; i++) ctx.lineTo(ring[i][0], ring[i][1]);
      ctx.closePath();
    }
  }

  function drawMultiPolygon(multiCoords) {
    for (const polyCoords of multiCoords) drawPolygonCoords(polyCoords);
  }

  // Draw a single ring (flat array of [x,y])
  function drawRing(ring) {
    if (!ring || ring.length === 0) return;
    ctx.beginPath();
    ctx.moveTo(ring[0][0], ring[0][1]);
    for (let i = 1; i < ring.length; i++) ctx.lineTo(ring[i][0], ring[i][1]);
    ctx.closePath();
  }

  function renderCity() {
    const w = canvas.clientWidth, h = canvas.clientHeight;
    ctx.fillStyle = CITY_COLORS.background;
    ctx.fillRect(0, 0, w, h);

    ctx.save();
    ctx.translate(panX, panY);
    ctx.scale(zoom, zoom);

    // Draw surrounding terrain before water/earth.
    for (const terr of cityData.terrain || []) {
      if (terr.type !== "Polygon" || !terr.coordinates) continue;
      const kind = String(terr.terrain || "plain").toLowerCase();
      if (kind === "mountain") {
        ctx.fillStyle = CITY_COLORS.terrainMountain;
        ctx.globalAlpha = 0.42;
      } else if (kind === "hill") {
        ctx.fillStyle = CITY_COLORS.terrainHill;
        ctx.globalAlpha = 0.34;
      } else {
        ctx.fillStyle = CITY_COLORS.terrainPlain;
        ctx.globalAlpha = 0.28;
      }
      drawPolygonCoords(terr.coordinates);
      ctx.fill();
    }
    ctx.globalAlpha = 1.0;

    // Draw water
    if (cityData.water && cityData.water.length > 0) { ctx.fillStyle = CITY_COLORS.water; drawMultiPolygon(cityData.water); ctx.fill(); }

    // Draw earth
    if (cityData.earth) { ctx.fillStyle = CITY_COLORS.earth; drawPolygonCoords(cityData.earth); ctx.fill(); }

    // Draw fields
    if (cityData.fields && cityData.fields.length > 0) { ctx.fillStyle = CITY_COLORS.field; drawMultiPolygon(cityData.fields); ctx.fill(); }

    // Draw greens
    if (cityData.greens && cityData.greens.length > 0) { ctx.fillStyle = CITY_COLORS.green; drawMultiPolygon(cityData.greens); ctx.fill(); }

    // Draw squares/plazas
    if (cityData.squares && cityData.squares.length > 0) { ctx.fillStyle = CITY_COLORS.road; drawMultiPolygon(cityData.squares); ctx.fill(); }

    // Draw rivers
    for (const river of cityData.rivers) {
      if (river.coordinates) {
        const wp = river.width_profile;
        if (Array.isArray(wp) && wp.length === river.coordinates.length && river.coordinates.length >= 2) {
          ctx.strokeStyle = CITY_COLORS.river;
          ctx.lineCap = "round"; ctx.lineJoin = "round";
          for (let i = 0; i < river.coordinates.length - 1; i++) {
            const w = (wp[i] + wp[i + 1]) * 0.5;
            ctx.lineWidth = w;
            drawCoordPath([river.coordinates[i], river.coordinates[i + 1]]);
            ctx.stroke();
          }
        } else {
          ctx.strokeStyle = CITY_COLORS.river;
          ctx.lineWidth = river.width || cityData.values?.riverWidth || 10;
          ctx.lineCap = "round"; ctx.lineJoin = "round";
          drawCoordPath(river.coordinates); ctx.stroke();
        }
      }
    }

    // Draw river islands (small land patches in wider channels)
    if (cityData.river_islands && cityData.river_islands.length > 0) {
      ctx.fillStyle = CITY_COLORS.earth;
      ctx.strokeStyle = "rgba(120, 110, 90, 0.32)";
      ctx.lineWidth = 0.8;
      drawMultiPolygon(cityData.river_islands);
      ctx.fill();
      ctx.stroke();
    }

    // Draw roads
    for (const road of cityData.roads) {
      if (road.coordinates) {
        ctx.strokeStyle = CITY_COLORS.road;
        ctx.lineWidth = road.width || cityData.values?.roadWidth || 8;
        ctx.lineCap = "round"; ctx.lineJoin = "round";
        drawCoordPath(road.coordinates); ctx.stroke();
      }
    }

    // Draw manual road preview while dragging.
    if (roadDraft && roadDraft.start && roadDraft.end) {
      ctx.strokeStyle = "rgba(180, 90, 40, 0.85)";
      ctx.lineWidth = (cityData.values?.roadWidth || 8) * 0.75;
      ctx.lineCap = "round";
      ctx.setLineDash([10 / zoom, 6 / zoom]);
      drawCoordPath([roadDraft.start, roadDraft.end]);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // Draw planks
    for (const plank of cityData.planks) {
      if (plank.coordinates) {
        const pw = plank.width || 4;
        ctx.strokeStyle = "rgba(70, 50, 30, 0.35)"; ctx.lineWidth = pw + 1.6; ctx.lineCap = "butt";
        drawCoordPath(plank.coordinates); ctx.stroke();
        ctx.strokeStyle = "#9a7a56"; ctx.lineWidth = pw; ctx.lineCap = "butt";
        drawCoordPath(plank.coordinates); ctx.stroke();
      }
    }

    // Draw buildings
    if (cityData.buildings && cityData.buildings.length > 0) {
      ctx.lineWidth = 0.5;
      for (let i = 0; i < cityData.buildings.length; i++) {
        const building = cityData.buildings[i];
        const isSelected = i === selectedBuildingIndex;
        const hasData = buildingData[i] && (buildingData[i].name || buildingData[i].dwelling);
        ctx.fillStyle = isSelected ? CITY_COLORS.buildingSelected : hasData ? "#b8c8a8" : CITY_COLORS.building;
        ctx.strokeStyle = isSelected ? "#8a4020" : CITY_COLORS.buildingStroke;
        ctx.lineWidth = isSelected ? 2 : 0.5;
        drawPolygonCoords(building); ctx.fill(); ctx.stroke();
      }

      if (selectedBuildingIndex !== null && activeTool === "rotate_building") {
        const c = buildingCenter(cityData.buildings[selectedBuildingIndex]);
        ctx.fillStyle = "rgba(180, 90, 40, 0.95)";
        ctx.beginPath();
        ctx.arc(c[0], c[1], 4 / zoom, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Draw prisms
    if (cityData.prisms && cityData.prisms.length > 0) {
      ctx.fillStyle = "#a8a498"; ctx.strokeStyle = CITY_COLORS.buildingStroke; ctx.lineWidth = 0.5;
      for (const prism of cityData.prisms) { drawPolygonCoords(prism); ctx.fill(); ctx.stroke(); }
    }

    // Draw trees
    if (cityData.trees && cityData.trees.length > 0) {
      ctx.fillStyle = CITY_COLORS.tree;
      if (Array.isArray(cityData.trees[0]) && typeof cityData.trees[0][0] === "number") {
        for (const pt of cityData.trees) { ctx.beginPath(); ctx.arc(pt[0], pt[1], 3, 0, Math.PI * 2); ctx.fill(); }
      } else {
        for (const tree of cityData.trees) { if (tree.coordinates) { ctx.beginPath(); ctx.arc(tree.coordinates[0], tree.coordinates[1], 3, 0, Math.PI * 2); ctx.fill(); } }
      }
    }

    // Draw walls (optional; disabled by default to reduce heavy perimeter outline)
    if (CITY_RENDER.showWalls) {
      for (const wall of cityData.walls) {
        if (wall.coordinates) {
          ctx.strokeStyle = CITY_COLORS.wall;
          ctx.lineWidth = wall.width || cityData.values?.wallThickness || 7;
          ctx.lineCap = "round"; ctx.lineJoin = "round";
          const coords = wall.coordinates[0];
          if (coords && coords.length > 0) {
            ctx.beginPath(); ctx.moveTo(coords[0][0], coords[0][1]);
            for (let i = 1; i < coords.length; i++) ctx.lineTo(coords[i][0], coords[i][1]);
            ctx.closePath(); ctx.stroke();
          }
        }
      }
    }

    // *** GAME SQUARES RENDERING ***
    if (showGameSquares && gameSquares.length > 0) {
      for (let i = 0; i < gameSquares.length; i++) {
        const square = gameSquares[i];
        const isSelected = i === selectedSquareIndex;
        let baseColor = square.color || getDistrictSquareColor(square.districtIndex);

        // Player-color tinting for controlled squares
        let fillAlpha = isSelected ? 0.45 : 0.2;
        if (square.boardState) {
          const controller = parseController(square.boardState.controller);
          if (controller.controlled && PLAYER_COLORS[controller.playerNum]) {
            baseColor = PLAYER_COLORS[controller.playerNum];
            fillAlpha = isSelected ? 0.5 : 0.3;
          }
        }

        // Fill
        ctx.fillStyle = adjustAlpha(baseColor, fillAlpha);
        drawRing(square.polygon);
        ctx.fill();

        // Stroke
        ctx.strokeStyle = isSelected ? adjustAlpha(baseColor, 0.95) : adjustAlpha(baseColor, 0.7);
        ctx.lineWidth = isSelected ? 3 / zoom : 1.5 / zoom;
        if (!isSelected) ctx.setLineDash([8 / zoom, 4 / zoom]);
        drawRing(square.polygon);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Draw square labels
      if (showLabels) {
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        for (let i = 0; i < gameSquares.length; i++) {
          const square = gameSquares[i];
          const isSelected = i === selectedSquareIndex;
          const baseColor = square.color || getDistrictSquareColor(square.districtIndex);
          const fontSize = Math.max(8, Math.min(14, Math.sqrt(square.area) / 20));
          ctx.font = `bold ${fontSize}px "Times New Roman", Georgia, serif`;

          // Draw label: use board state name if available, else generated name
          const label = square.name.replace(square.districtName + " ", "");
          const metrics = ctx.measureText(label);
          const pad = 2;
          ctx.fillStyle = "rgba(245,242,235,0.75)";
          ctx.fillRect(
            square.centroid[0] - metrics.width / 2 - pad,
            square.centroid[1] - fontSize / 2 - pad,
            metrics.width + pad * 2,
            fontSize + pad * 2
          );

          ctx.fillStyle = isSelected ? adjustAlpha(baseColor, 1.0) : adjustAlpha(baseColor, 0.9);
          ctx.fillText(label, square.centroid[0], square.centroid[1]);

          // VP badge (small number in upper-right of square)
          if (square.boardState && square.boardState.vp !== undefined) {
            const vp = square.boardState.vp;
            const vpSize = Math.max(6, fontSize * 0.7);
            ctx.font = `bold ${vpSize}px "Times New Roman", serif`;
            const vpColor = vp > 0 ? '#44aa44' : vp < 0 ? '#cc4444' : '#888';
            const vpX = square.centroid[0] + metrics.width / 2 + 8;
            const vpY = square.centroid[1] - fontSize / 2 - 2;
            ctx.fillStyle = "rgba(245,242,235,0.85)";
            const vpText = `${vp}vp`;
            const vpMetrics = ctx.measureText(vpText);
            ctx.fillRect(vpX - 2, vpY - vpSize / 2 - 1, vpMetrics.width + 4, vpSize + 2);
            ctx.fillStyle = vpColor;
            ctx.fillText(vpText, vpX, vpY);
          }

          // Influence badge (number at centroid below label)
          if (square.boardState && square.boardState.influence > 0) {
            const inf = square.boardState.influence;
            const infSize = Math.max(7, fontSize * 0.8);
            ctx.font = `bold ${infSize}px "Times New Roman", serif`;
            const infY = square.centroid[1] + fontSize / 2 + infSize;
            ctx.fillStyle = "rgba(245,242,235,0.85)";
            const infText = `inf:${inf}`;
            const infMetrics = ctx.measureText(infText);
            ctx.fillRect(square.centroid[0] - infMetrics.width / 2 - 2, infY - infSize / 2 - 1, infMetrics.width + 4, infSize + 2);
            ctx.fillStyle = "#5566aa";
            ctx.fillText(infText, square.centroid[0], infY);
          }
        }
      }
    }

    // Draw grid
    if (showGrid) {
      const { minX, maxX, minY, maxY } = cityData.bounds;
      const gridSize = Math.pow(10, Math.floor(Math.log10(Math.max(maxX - minX, maxY - minY) / 5)));
      const adjustedGridSize = gridSize * (gridSize < 100 ? 2 : 1);
      ctx.strokeStyle = CITY_COLORS.grid; ctx.lineWidth = 1 / zoom;
      const startX = Math.floor(minX / adjustedGridSize) * adjustedGridSize;
      const startY = Math.floor(minY / adjustedGridSize) * adjustedGridSize;
      for (let x = startX; x <= maxX; x += adjustedGridSize) { ctx.beginPath(); ctx.moveTo(x, minY); ctx.lineTo(x, maxY); ctx.stroke(); }
      for (let y = startY; y <= maxY; y += adjustedGridSize) { ctx.beginPath(); ctx.moveTo(minX, y); ctx.lineTo(maxX, y); ctx.stroke(); }
    }

    // Draw district labels
    if (showLabels && cityData.districts) {
      ctx.fillStyle = CITY_COLORS.district;
      ctx.textAlign = "center"; ctx.textBaseline = "middle";
      for (const district of cityData.districts) {
        if (district.name && district.coordinates) {
          const ring = district.coordinates[0];
          let cx = 0, cy = 0;
          for (const pt of ring) { cx += pt[0]; cy += pt[1]; }
          cx /= ring.length; cy /= ring.length;
          let dMinX = Infinity, dMaxX = -Infinity, dMinY = Infinity, dMaxY = -Infinity;
          for (const pt of ring) { dMinX = Math.min(dMinX, pt[0]); dMaxX = Math.max(dMaxX, pt[0]); dMinY = Math.min(dMinY, pt[1]); dMaxY = Math.max(dMaxY, pt[1]); }
          const size = Math.min(dMaxX - dMinX, dMaxY - dMinY);
          const fontSize = Math.max(12, Math.min(size / 6, 80));
          ctx.font = `bold ${fontSize}px "Times New Roman", Georgia, serif`;
          ctx.fillStyle = "rgba(40, 40, 30, 0.7)";
          ctx.fillText(district.name.toUpperCase(), cx, cy);
        }
      }
    }

    ctx.restore();

    drawCompassRose(w - 70, h - 70, 50);
    drawScaleBar(30, h - 40);

    if (cityData.name || cityData.values?.name) {
      ctx.fillStyle = "#1a1a1a"; ctx.font = "bold 24px 'Times New Roman', Georgia, serif"; ctx.textAlign = "center";
      ctx.fillText(cityData.name || cityData.values?.name || "City Map", w / 2, 35);
    }
  }

  function drawCompassRose(cx, cy, size) {
    ctx.save(); ctx.translate(cx, cy);
    ctx.strokeStyle = "rgba(40, 40, 30, 0.5)"; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.arc(0, 0, size, 0, Math.PI * 2); ctx.stroke();
    const r = size * 0.85;
    ctx.fillStyle = "rgba(40, 40, 30, 0.8)"; ctx.font = "bold 14px 'Times New Roman', Georgia, serif";
    ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText("N", 0, -r);
    ctx.beginPath();
    for (let i = 0; i < 8; i++) { const angle = (i * Math.PI / 4) - Math.PI / 2; const len = i % 2 === 0 ? size * 0.6 : size * 0.35; ctx.moveTo(0, 0); ctx.lineTo(Math.cos(angle) * len, Math.sin(angle) * len); }
    ctx.strokeStyle = "rgba(40, 40, 30, 0.6)"; ctx.lineWidth = 1.5; ctx.stroke();
    ctx.fillStyle = "rgba(40, 40, 30, 0.7)"; ctx.beginPath();
    ctx.moveTo(0, -size * 0.5); ctx.lineTo(-6, 0); ctx.lineTo(0, -size * 0.15); ctx.lineTo(6, 0); ctx.closePath(); ctx.fill();
    ctx.restore();
  }

  function drawScaleBar(x, y) {
    if (!cityData) return;
    const { minX, maxX } = cityData.bounds;
    const screenWidth = 150;
    const mapDistance = screenWidth / zoom;
    const magnitude = Math.pow(10, Math.floor(Math.log10(mapDistance)));
    let niceDistance = magnitude;
    if (mapDistance / magnitude >= 5) niceDistance = magnitude * 5;
    else if (mapDistance / magnitude >= 2) niceDistance = magnitude * 2;
    const barWidth = niceDistance * zoom;
    ctx.fillStyle = "rgba(40, 40, 30, 0.8)"; ctx.strokeStyle = "rgba(40, 40, 30, 0.8)"; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + barWidth, y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x, y - 5); ctx.lineTo(x, y + 5); ctx.moveTo(x + barWidth, y - 5); ctx.lineTo(x + barWidth, y + 5); ctx.stroke();
    ctx.font = "12px 'Times New Roman', Georgia, serif"; ctx.textAlign = "left"; ctx.fillText("0", x, y - 10);
    ctx.textAlign = "right";
    const label = niceDistance >= 1000 ? `${niceDistance/1000}km` : `${niceDistance}m`;
    ctx.fillText(label, x + barWidth, y - 10);
  }

  // --- Hex map rendering ---
  function drawMiniCity(cx, cy, size, type) {
    const scale = type === 'city' ? 1.3 : type === 'town' ? 1.0 : 0.7;
    const s = size * scale;
    ctx.fillStyle = HEX_COLORS.townFill; ctx.strokeStyle = HEX_COLORS.townStroke; ctx.lineWidth = 0.8;
    const buildings = type === 'city' ? [
      { x: 0, y: 0, w: s*0.5, h: s*0.6 }, { x: -s*0.5, y: -s*0.2, w: s*0.35, h: s*0.4 },
      { x: s*0.35, y: -s*0.15, w: s*0.3, h: s*0.35 }, { x: -s*0.35, y: s*0.35, w: s*0.4, h: s*0.3 },
      { x: s*0.25, y: s*0.3, w: s*0.35, h: s*0.35 }, { x: -s*0.6, y: s*0.15, w: s*0.25, h: s*0.25 },
      { x: s*0.55, y: s*0.05, w: s*0.25, h: s*0.3 },
    ] : type === 'town' ? [
      { x: 0, y: 0, w: s*0.45, h: s*0.5 }, { x: -s*0.4, y: 0, w: s*0.3, h: s*0.35 },
      { x: s*0.35, y: -s*0.1, w: s*0.28, h: s*0.32 }, { x: 0, y: s*0.35, w: s*0.35, h: s*0.25 },
    ] : [
      { x: 0, y: 0, w: s*0.4, h: s*0.35 }, { x: -s*0.3, y: s*0.15, w: s*0.25, h: s*0.22 },
      { x: s*0.25, y: s*0.1, w: s*0.22, h: s*0.25 },
    ];
    if (type === 'city') { ctx.strokeStyle = HEX_COLORS.townStroke; ctx.lineWidth = 1.2; ctx.beginPath(); ctx.arc(cx, cy, s * 0.85, 0, Math.PI * 2); ctx.stroke(); }
    ctx.fillStyle = HEX_COLORS.townFill; ctx.strokeStyle = HEX_COLORS.townStroke; ctx.lineWidth = 0.6;
    for (const b of buildings) { ctx.fillRect(cx + b.x - b.w/2, cy + b.y - b.h/2, b.w, b.h); ctx.strokeRect(cx + b.x - b.w/2, cy + b.y - b.h/2, b.w, b.h); }
  }

  function drawDangerIcon(cx, cy, size) {
    const s = size;
    ctx.fillStyle = HEX_COLORS.dangerFill; ctx.strokeStyle = HEX_COLORS.dangerStroke; ctx.lineWidth = 0.8;
    ctx.beginPath();
    ctx.moveTo(cx - s*0.4, cy + s*0.4); ctx.lineTo(cx - s*0.35, cy - s*0.2);
    ctx.lineTo(cx - s*0.3, cy - s*0.25); ctx.lineTo(cx - s*0.25, cy - s*0.4);
    ctx.lineTo(cx - s*0.1, cy - s*0.35); ctx.lineTo(cx, cy - s*0.5);
    ctx.lineTo(cx + s*0.15, cy - s*0.3); ctx.lineTo(cx + s*0.25, cy - s*0.45);
    ctx.lineTo(cx + s*0.35, cy - s*0.25); ctx.lineTo(cx + s*0.35, cy - s*0.15);
    ctx.lineTo(cx + s*0.4, cy + s*0.4);
    ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.fillStyle = HEX_COLORS.dangerStroke; ctx.fillRect(cx - s*0.1, cy + s*0.1, s*0.2, s*0.3);
  }

  function renderHex() {
    const w = canvas.clientWidth, h = canvas.clientHeight;
    ctx.fillStyle = HEX_COLORS.background; ctx.fillRect(0, 0, w, h);
    if (!map) return;
    ctx.save(); ctx.translate(panX, panY); ctx.scale(zoom, zoom);

    for (const rec of hitIndex) { drawPoly(rec.poly); ctx.fillStyle = getTerrainColor(rec.hexObj.terrain || "unknown"); ctx.fill(); }
    if (showGrid) { ctx.strokeStyle = HEX_COLORS.grid; ctx.lineWidth = 1 / zoom; for (const rec of hitIndex) { drawPoly(rec.poly); ctx.stroke(); } }

    const iconSize = hexSize * 0.6;
    for (const rec of hitIndex) {
      if (rec.hexObj.town) drawMiniCity(rec.cx, rec.cy, iconSize, rec.hexObj.town.type || 'town');
      if (rec.hexObj.danger) drawDangerIcon(rec.cx, rec.cy, iconSize);
    }

    if (showLabels) {
      ctx.textAlign = "center"; ctx.textBaseline = "top";
      for (const rec of hitIndex) {
        const label = rec.hexObj.town?.name || rec.hexObj.danger?.name;
        if (label) {
          ctx.font = "bold 10px 'Times New Roman', Georgia, serif";
          ctx.fillStyle = HEX_COLORS.label;
          ctx.shadowColor = "rgba(255,255,255,0.8)"; ctx.shadowBlur = 2;
          ctx.fillText(label, rec.cx, rec.cy + hexSize * 0.5);
          ctx.shadowBlur = 0;
        }
      }
    }
    ctx.restore();

    drawHexCompassRose(w - 70, h - 70, 50);
    drawHexScaleBar(30, h - 40);
    if (map.name) { ctx.fillStyle = "rgba(40, 35, 25, 0.9)"; ctx.font = "bold 24px 'Times New Roman', Georgia, serif"; ctx.textAlign = "center"; ctx.fillText(map.name, w / 2, 35); }
  }

  function drawHexCompassRose(cx, cy, size) {
    ctx.save(); ctx.translate(cx, cy);
    ctx.strokeStyle = "rgba(60, 55, 45, 0.5)"; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(0, 0, size, 0, Math.PI * 2); ctx.stroke();
    const r = size * 0.85;
    ctx.fillStyle = "rgba(60, 55, 45, 0.8)"; ctx.font = "bold 14px 'Times New Roman', Georgia, serif";
    ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText("N", 0, -r);
    ctx.beginPath();
    for (let i = 0; i < 8; i++) { const angle = (i * Math.PI / 4) - Math.PI / 2; const len = i % 2 === 0 ? size * 0.6 : size * 0.35; ctx.moveTo(0, 0); ctx.lineTo(Math.cos(angle) * len, Math.sin(angle) * len); }
    ctx.strokeStyle = "rgba(60, 55, 45, 0.6)"; ctx.lineWidth = 1.5; ctx.stroke();
    ctx.fillStyle = "rgba(60, 55, 45, 0.7)"; ctx.beginPath();
    ctx.moveTo(0, -size * 0.5); ctx.lineTo(-6, 0); ctx.lineTo(0, -size * 0.15); ctx.lineTo(6, 0); ctx.closePath(); ctx.fill();
    ctx.restore();
  }

  function drawHexScaleBar(x, y) {
    if (!map || !bounds) return;
    const hexWidthMiles = 6;
    const screenWidth = 150;
    const worldWidth = screenWidth / zoom;
    const hexesInBar = worldWidth / (hexSize * 1.5);
    const distanceMiles = hexesInBar * hexWidthMiles;
    const magnitude = Math.pow(10, Math.floor(Math.log10(distanceMiles)));
    let niceDistance = magnitude;
    if (distanceMiles / magnitude >= 5) niceDistance = magnitude * 5;
    else if (distanceMiles / magnitude >= 2) niceDistance = magnitude * 2;
    const barWidth = (niceDistance / hexWidthMiles) * (hexSize * 1.5) * zoom;
    ctx.fillStyle = "rgba(60, 55, 45, 0.8)"; ctx.strokeStyle = "rgba(60, 55, 45, 0.8)"; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + barWidth, y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x, y - 5); ctx.lineTo(x, y + 5); ctx.moveTo(x + barWidth, y - 5); ctx.lineTo(x + barWidth, y + 5); ctx.stroke();
    ctx.font = "12px 'Times New Roman', Georgia, serif"; ctx.textAlign = "left"; ctx.fillText("0", x, y - 10);
    ctx.textAlign = "right"; ctx.fillText(`${niceDistance} mi`, x + barWidth, y - 10);
  }

  // --- Main render ---
  function render() {
    if (mapType === 'city') {
      if (cityData) renderCity();
      else ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
    }
    else if (mapType === 'hex') renderHex();
    else ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
  }

  function fitToScreen() {
    if (mapType === 'city') {
      if (cityData) fitCityToScreen();
    }
    else if (mapType === 'hex') fitHexToScreen();
    render();
  }

  function setMeta() {
    if (mapType === 'city') {
      const name = cityData?.name || cityData?.values?.name || "City Map";
      const gen = cityData?.values?.generator || "unknown";
      const ver = cityData?.values?.version || "";
      meta.textContent = `${name}  generator=${gen} ${ver}`;
    } else {
      const tags = (map.bp && map.bp.tags) ? map.bp.tags.join(", ") : "";
      meta.textContent = `${map.name || "Untitled"}  layout=${map.layout}  tags=${tags}`;
    }
  }

  function setLegend() {
    legend.innerHTML = "";
    if (mapType === 'city') return;
    const used = new Set();
    for (const k in map.hexes) used.add(map.hexes[k].terrain || "unknown");
    [...used].sort().slice(0, 24).forEach(t => {
      const chip = document.createElement("span");
      chip.className = "chip clickable"; chip.dataset.terrain = t;
      const c = getTerrainColor(t);
      chip.style.borderColor = "#5a5a4a"; chip.style.background = "#e8e4d8"; chip.style.color = "#3a3a2a";
      chip.innerHTML = `<span class="color-swatch" style="display:inline-block;width:10px;height:10px;border-radius:3px;background:${c};margin-right:8px;vertical-align:-1px;border:1px solid #8a8a7a"></span>${t}`;
      chip.title = "Click to change color";
      chip.addEventListener("click", () => openColorPicker(t, chip));
      legend.appendChild(chip);
    });
  }

  function openColorPicker(terrain, chip) {
    const picker = document.getElementById("colorPicker");
    picker.value = getTerrainColor(terrain);
    const rect = chip.getBoundingClientRect();
    picker.style.left = rect.left + "px"; picker.style.top = rect.bottom + "px";
    const onChange = (e) => {
      customColors[terrain] = e.target.value;
      const swatch = chip.querySelector(".color-swatch");
      if (swatch) swatch.style.background = e.target.value;
      if (terrain === "water") HEX_COLORS.background = e.target.value;
      document.getElementById("export").style.display = "inline-block";
      render();
    };
    picker.addEventListener("input", onChange);
    picker.addEventListener("change", () => picker.removeEventListener("input", onChange), { once: true });
    picker.click();
  }

  function exportMap() {
    if (!map) return;
    const exportData = JSON.parse(JSON.stringify(map));
    if (Object.keys(customColors).length > 0) exportData.customColors = { ...customColors };
    if (Object.keys(buildingData).length > 0) exportData.buildingData = { ...buildingData };

    // Export game squares (including board state data if present)
    if (gameSquares.length > 0) {
      exportData.gameSquares = gameSquares.map(sq => ({
        id: sq.id, name: sq.name, districtIndex: sq.districtIndex,
        polygon: sq.polygon, buildingIndices: sq.buildingIndices,
        generationType: sq.generationType, notes: sq.notes, color: sq.color,
        boardStateId: sq.boardStateId || null,
        boardState: sq.boardState || null,
        boardStateDistrict: sq.boardStateDistrict || null,
      }));
    }

    // Export loaded board state
    if (loadedBoardState) {
      exportData.loadedBoardState = loadedBoardState;
    }

    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = currentFileName.replace(/\.json$/i, "_custom.json");
    document.body.appendChild(a); a.click(); document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  function screenToWorld(sx, sy) { return { x: (sx - panX) / zoom, y: (sy - panY) / zoom }; }

  function findHexAtWorld(x, y) {
    for (let i = 0; i < hitIndex.length; i++) { if (pointInPoly(x, y, hitIndex[i].poly)) return hitIndex[i]; }
    return null;
  }

  function showTip(rec, clientX, clientY) {
    const h = rec.hexObj;
    let title = `Hex q${rec.q} r${rec.r}`;
    let lines = [`<div class="k">terrain</div><div>${h.terrain || "unknown"}</div>`];
    if (h.town) {
      lines.push(`<div class="k" style="margin-top:8px">town</div><div><b>${h.town.name}</b> (${h.town.type})</div>`);
      if (h.town.info) lines.push(`<div style="opacity:.9;margin-top:4px">${escapeHtml(h.town.info)}</div>`);
      if (h.town.link) lines.push(`<div style="margin-top:6px;opacity:.9">Click to open generator link</div>`);
    }
    if (h.danger) {
      lines.push(`<div class="k" style="margin-top:8px">danger</div><div><b>${h.danger.name}</b></div>`);
      if (h.danger.link) lines.push(`<div style="margin-top:6px;opacity:.9">Click to open dungeon link</div>`);
    }
    tip.innerHTML = `<div class="t">${title}</div>${lines.join("")}`;
    tip.style.display = "block"; tip.style.left = `${clientX + 14}px`; tip.style.top = `${clientY + 14}px`;
  }

  function showCityTip(district, clientX, clientY) {
    tip.innerHTML = `<div class="t">${district.name}</div>`;
    tip.style.display = "block"; tip.style.left = `${clientX + 14}px`; tip.style.top = `${clientY + 14}px`;
  }

  function hideTip() { tip.style.display = "none"; }

  function escapeHtml(s) {
    return String(s).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll('"',"&quot;").replaceAll("'","&#039;");
  }

  function detectMapType(data) {
    if (data.type === "FeatureCollection" && data.features) return 'city';
    if (data.hexes && data.layout) return 'hex';
    return null;
  }

  // =============================================
  // UI Wiring
  // =============================================

  document.getElementById("editToggleGridBtn").addEventListener("click", () => {
    showGrid = !showGrid;
    syncEditPanelToggleButtons();
    render();
  });
  document.getElementById("editToggleLabelsBtn").addEventListener("click", () => {
    showLabels = !showLabels;
    syncEditPanelToggleButtons();
    render();
  });
  document.getElementById("fit").addEventListener("click", fitToScreen);
  document.getElementById("export").addEventListener("click", exportMap);
  document.getElementById("editMapBtn").addEventListener("click", () => {
    const panel = document.getElementById("editToolsPanel");
    const currentlyVisible = panel && panel.classList.contains("visible");
    setEditPanelVisible(!currentlyVisible);
    if (currentlyVisible) setActiveTool(null);
  });
  document.getElementById("editMoveBuildingsBtn").addEventListener("click", () => setActiveTool("move_building"));
  document.getElementById("editRotateBuildingsBtn").addEventListener("click", () => setActiveTool("rotate_building"));
  document.getElementById("editAddRoadBtn").addEventListener("click", () => setActiveTool("add_road"));
  document.getElementById("duplicateBuildingBtn").addEventListener("click", () => duplicateSelectedBuilding());

  // Generate Squares button
  document.getElementById("generateSquaresBtn").addEventListener("click", () => {
    if (!cityData) return;
    if (gameSquares.length > 0) {
      if (!confirm("This will regenerate all game squares. Continue?")) return;
    }
    gameSquares = generateGameSquares(7, loadedBoardState);
    showGameSquares = true;
    document.getElementById("toggleSquaresBtn").style.display = "inline-block";
    document.getElementById("toggleSquaresBtn").classList.add("active");
    document.getElementById("export").style.display = "inline-block";
    render();
  });

  // Load Board State button
  document.getElementById("boardStateFile").addEventListener("change", async (e) => {
    const f = e.target.files?.[0];
    if (!f) return;
    try {
      const txt = await f.text();
      loadedBoardState = JSON.parse(txt);
      const nDistricts = Object.keys(loadedBoardState.districts || {}).length;
      const nSquares = Object.values(loadedBoardState.districts || {}).reduce(
        (sum, d) => sum + Object.keys(d.squares || {}).length, 0
      );
      console.log(`Board state loaded: ${nDistricts} districts, ${nSquares} squares`);
      alert(`Board state loaded: ${nDistricts} districts, ${nSquares} total squares.\n\nClick "Generate Squares" to create squares matching the board state.`);

      // If squares already exist, offer to regenerate
      if (gameSquares.length > 0) {
        if (confirm("Regenerate squares with board state data?")) {
          gameSquares = generateGameSquares(7, loadedBoardState);
          showGameSquares = true;
          render();
        }
      }
    } catch (err) {
      alert("Failed to parse board state: " + err.message);
    }
  });

  // Toggle Squares button
  document.getElementById("toggleSquaresBtn").addEventListener("click", () => {
    showGameSquares = !showGameSquares;
    const btn = document.getElementById("toggleSquaresBtn");
    if (showGameSquares) btn.classList.add("active");
    else btn.classList.remove("active");
    render();
  });

  // File loading
  document.getElementById("file").addEventListener("change", async (e) => {
    const f = e.target.files?.[0];
    if (!f) return;
    const txt = await f.text();
    const data = JSON.parse(txt);

    currentFileName = f.name;
    mapType = detectMapType(data);

    customColors = {};
    if (data.customColors) {
      customColors = { ...data.customColors };
      if (customColors.water) HEX_COLORS.background = customColors.water;
      document.getElementById("export").style.display = "inline-block";
    } else {
      HEX_COLORS.background = "#9a9a8a";
      document.getElementById("export").style.display = "none";
    }

    buildingData = {};
    selectedBuildingIndex = null;
    document.getElementById("buildingPanel").classList.remove("visible");
    if (data.buildingData) buildingData = { ...data.buildingData };

    // Reset game squares and board state
    gameSquares = [];
    showGameSquares = false;
    selectedSquareIndex = null;
    loadedBoardState = null;
    setActiveTool(null);
    setEditPanelVisible(false);
    document.getElementById("squarePanel").classList.remove("visible");
    document.getElementById("toggleSquaresBtn").style.display = "none";
    document.getElementById("toggleSquaresBtn").classList.remove("active");

    if (mapType === 'city') {
      map = data;
      cityData = parseCityMap(data);
      if (!cityData.name && !cityData.values?.name) {
        cityData.name = f.name.replace(/\.json$/i, '').replace(/_/g, ' ');
        cityData.name = cityData.name.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
      }

      // Show generate squares button and board state loader for city maps with districts
      if (cityData.districts && cityData.districts.length > 0) {
        document.getElementById("generateSquaresBtn").style.display = "inline-block";
        document.getElementById("boardStateLabel").style.display = "inline-block";
        document.getElementById("editMapBtn").style.display = "inline-block";
      } else {
        document.getElementById("generateSquaresBtn").style.display = "none";
        document.getElementById("boardStateLabel").style.display = "none";
        document.getElementById("editMapBtn").style.display = "none";
        setEditPanelVisible(false);
      }

      // Restore loaded board state if present in exported data
      if (data.loadedBoardState) {
        loadedBoardState = data.loadedBoardState;
      }

      // Load saved game squares if present
      if (data.gameSquares && Array.isArray(data.gameSquares)) {
        gameSquares = data.gameSquares.map(sq => {
          const centroid = polygonCentroid(sq.polygon);
          const area = ringArea(sq.polygon);
          const bounds = ringBounds(sq.polygon);
          return {
            ...sq,
            districtName: cityData.districts[sq.districtIndex]?.name || "Unknown",
            centroid, area, bounds,
            buildingCount: sq.buildingIndices.length,
            notes: sq.notes || "",
            color: sq.color || null,
            boardStateId: sq.boardStateId || null,
            boardState: sq.boardState || null,
            boardStateDistrict: sq.boardStateDistrict || null,
          };
        });
        showGameSquares = true;
        document.getElementById("toggleSquaresBtn").style.display = "inline-block";
        document.getElementById("toggleSquaresBtn").classList.add("active");
      }

      setMeta(); setLegend(); fitCityToScreen(); render();
    } else if (mapType === 'hex') {
      map = data; cityData = null;
      document.getElementById("generateSquaresBtn").style.display = "none";
      document.getElementById("boardStateLabel").style.display = "none";
      document.getElementById("editMapBtn").style.display = "none";
      setEditPanelVisible(false);
      setActiveTool(null);
      setMeta(); setLegend(); rebuildHitIndex(); fitHexToScreen(); render();
    } else {
      alert("Unknown map format.");
    }
  });

  // Mouse interactions
  canvas.addEventListener("mousedown", (e) => {
    if (!map) return;
    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
    const w = screenToWorld(sx, sy);

    if (mapType === "city" && activeTool) {
      if (activeTool === "move_building") {
        const idx = findBuildingAtWorld(w.x, w.y);
        if (idx !== null) {
          selectedBuildingIndex = idx;
          selectedSquareIndex = null;
          hideSquarePanel();
          showBuildingPanel(idx);
          dragBuilding = { index: idx, lastWorldX: w.x, lastWorldY: w.y };
          suppressNextClick = true;
          render();
        }
        return;
      }
      if (activeTool === "rotate_building") {
        const idx = findBuildingAtWorld(w.x, w.y);
        if (idx !== null) {
          selectedBuildingIndex = idx;
          selectedSquareIndex = null;
          hideSquarePanel();
          showBuildingPanel(idx);
          const c = buildingCenter(cityData.buildings[idx]);
          rotateBuilding = {
            index: idx,
            center: c,
            lastAngle: Math.atan2(w.y - c[1], w.x - c[0]),
          };
          suppressNextClick = true;
          render();
        }
        return;
      }
      if (activeTool === "add_road") {
        roadDraft = { start: [w.x, w.y], end: [w.x, w.y] };
        suppressNextClick = true;
        render();
        return;
      }
    }

    isPanning = true;
    lastX = e.clientX;
    lastY = e.clientY;
  });

  window.addEventListener("mouseup", (e) => {
    const wasDraggingBuilding = !!dragBuilding;
    const wasRotatingBuilding = !!rotateBuilding;
    const wasDrawingRoad = !!roadDraft;

    if (mapType === "city" && activeTool) {
      if (activeTool === "add_road" && roadDraft) {
        const dx = roadDraft.end[0] - roadDraft.start[0];
        const dy = roadDraft.end[1] - roadDraft.start[1];
        const len = Math.sqrt(dx * dx + dy * dy);
        if (len >= 10) {
          cityData.roads.push({
            type: "LineString",
            width: Math.max(4, (cityData.values?.roadWidth || 8) * 0.75),
            coordinates: [
              [roadDraft.start[0], roadDraft.start[1]],
              [roadDraft.end[0], roadDraft.end[1]],
            ],
          });
          document.getElementById("export").style.display = "inline-block";
        }
      }

      dragBuilding = null;
      rotateBuilding = null;
      roadDraft = null;
    }

    if (wasDraggingBuilding || wasRotatingBuilding || wasDrawingRoad) {
      if (wasDraggingBuilding || wasRotatingBuilding) refreshSquareBuildingAssignments();
      suppressNextClick = true;
      render();
    }
    isPanning = false;
  });

  window.addEventListener("mousemove", (e) => {
    if (isPanning) {
      panX += (e.clientX - lastX); panY += (e.clientY - lastY);
      lastX = e.clientX; lastY = e.clientY; render(); return;
    }
    if (!map) return;
    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
    const w = screenToWorld(sx, sy);

    if (mapType === "city" && activeTool) {
      hideTip();

      if (activeTool === "move_building" && dragBuilding) {
        const dx = w.x - dragBuilding.lastWorldX;
        const dy = w.y - dragBuilding.lastWorldY;
        if (Math.abs(dx) > 1e-6 || Math.abs(dy) > 1e-6) {
          moveBuilding(dragBuilding.index, dx, dy);
          dragBuilding.lastWorldX = w.x;
          dragBuilding.lastWorldY = w.y;
          document.getElementById("export").style.display = "inline-block";
          render();
        }
        return;
      }

      if (activeTool === "rotate_building" && rotateBuilding) {
        const c = rotateBuilding.center;
        const ang = Math.atan2(w.y - c[1], w.x - c[0]);
        let delta = ang - rotateBuilding.lastAngle;
        if (delta > Math.PI) delta -= Math.PI * 2;
        if (delta < -Math.PI) delta += Math.PI * 2;
        if (Math.abs(delta) > 1e-6) {
          rotateBuildingBy(rotateBuilding.index, c, delta);
          rotateBuilding.lastAngle = ang;
          document.getElementById("export").style.display = "inline-block";
          render();
        }
        return;
      }

      if (activeTool === "add_road" && roadDraft) {
        roadDraft.end = [w.x, w.y];
        render();
        return;
      }
    }

    if (mapType === 'hex') {
      const rec = findHexAtWorld(w.x, w.y);
      if (rec) showTip(rec, e.clientX - rect.left, e.clientY - rect.top);
      else hideTip();
    } else if (mapType === 'city') {
      // Show tooltip for game squares on hover
      if (showGameSquares && gameSquares.length > 0) {
        const sqIdx = findSquareAtWorld(w.x, w.y);
        if (sqIdx !== null) {
          const sq = gameSquares[sqIdx];
          let tipHtml = `<div class="t">${sq.name}</div><div class="k">district</div><div>${sq.districtName}</div>`;
          if (sq.boardState) {
            const bs = sq.boardState;
            const vp = bs.vp || 0;
            const vpColor = vp > 0 ? '#44aa44' : vp < 0 ? '#cc4444' : '#888';
            tipHtml += `<div class="k" style="margin-top:4px">vp</div><div style="color:${vpColor};font-weight:bold">${vp}</div>`;
            if (bs.influence > 0) tipHtml += `<div class="k" style="margin-top:4px">influence</div><div>${bs.influence}</div>`;
            const controller = parseController(bs.controller);
            if (controller.controlled) {
              const pCol = PLAYER_COLORS[controller.playerNum] || '#888';
              tipHtml += `<div class="k" style="margin-top:4px">controller</div><div style="color:${pCol};font-weight:bold">${controller.label}</div>`;
            }
          } else {
            tipHtml += `<div class="k" style="margin-top:4px">buildings</div><div>${sq.buildingCount}</div>`;
          }
          tip.innerHTML = tipHtml;
          tip.style.display = "block";
          tip.style.left = `${e.clientX - rect.left + 14}px`;
          tip.style.top = `${e.clientY - rect.top + 14}px`;
        } else {
          hideTip();
        }
      } else {
        hideTip();
      }
    }
  });

  canvas.addEventListener("click", (e) => {
    if (suppressNextClick) {
      suppressNextClick = false;
      return;
    }
    if (!map) return;
    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
    const w = screenToWorld(sx, sy);

    if (mapType === 'hex') {
      const rec = findHexAtWorld(w.x, w.y);
      if (!rec) return;
      const url = rec.hexObj.town?.link || rec.hexObj.danger?.link;
      if (url) window.open(url, "_blank", "noopener,noreferrer");
    } else if (mapType === 'city') {
      if (activeTool) return;
      // Check game squares first
      if (showGameSquares && gameSquares.length > 0) {
        const sqIdx = findSquareAtWorld(w.x, w.y);
        if (sqIdx !== null) {
          selectedSquareIndex = sqIdx;
          selectedBuildingIndex = null;
          hideBuildingPanel();
          showSquarePanel(sqIdx);
          render();
          return;
        }
      }

      // Then check buildings
      const buildingIdx = findBuildingAtWorld(w.x, w.y);
      if (buildingIdx !== null) {
        selectedBuildingIndex = buildingIdx;
        selectedSquareIndex = null;
        hideSquarePanel();
        showBuildingPanel(buildingIdx);
        render();
      }
    }
  });

  canvas.addEventListener("wheel", (e) => {
    if (!map) return;
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
    const before = screenToWorld(sx, sy);
    const delta = Math.sign(e.deltaY);
    zoom = Math.max(0.01, Math.min(50, zoom * (delta > 0 ? 0.9 : 1.1)));
    const after = screenToWorld(sx, sy);
    panX += (after.x - before.x) * zoom; panY += (after.y - before.y) * zoom;
    render();
  }, { passive:false });

  // Panel event handlers
  document.getElementById("closeBuildingPanel").addEventListener("click", hideBuildingPanel);
  document.getElementById("closeSquarePanel").addEventListener("click", hideSquarePanel);

  document.getElementById("generateDwelling").addEventListener("click", () => {
    if (selectedBuildingIndex === null) return;
    const dwelling = generateDwelling(selectedBuildingIndex);
    if (!buildingData[selectedBuildingIndex]) buildingData[selectedBuildingIndex] = {};
    buildingData[selectedBuildingIndex].dwelling = dwelling;
    document.getElementById("dwellingSection").style.display = "block";
    updateFloorTabs(dwelling); render();
    document.getElementById("export").style.display = "inline-block";
  });

  document.getElementById("saveBuildingInfo").addEventListener("click", () => {
    if (selectedBuildingIndex === null) return;
    const name = document.getElementById("buildingName").value.trim();
    const notes = document.getElementById("buildingNotes").value.trim();
    if (!buildingData[selectedBuildingIndex]) buildingData[selectedBuildingIndex] = {};
    if (name) buildingData[selectedBuildingIndex].name = name; else delete buildingData[selectedBuildingIndex].name;
    if (notes) buildingData[selectedBuildingIndex].notes = notes; else delete buildingData[selectedBuildingIndex].notes;
    if (Object.keys(buildingData[selectedBuildingIndex]).length === 0) delete buildingData[selectedBuildingIndex];
    render(); document.getElementById("export").style.display = "inline-block";
  });

  document.getElementById("saveSquareInfo").addEventListener("click", () => {
    if (selectedSquareIndex === null) return;
    const square = gameSquares[selectedSquareIndex];
    const newName = document.getElementById("squareName").value.trim();
    if (newName) square.name = newName;
    square.notes = document.getElementById("squareNotes").value.trim();
    document.getElementById("squareTitle").textContent = square.name;
    document.getElementById("export").style.display = "inline-block";
    render();
  });

  window.addEventListener("resize", resize);
  resize();
})();
</script>
</body>
</html>
